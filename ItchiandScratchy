local Icon = Instance.new("ModuleScript")
Icon.Name = "Icon"
Icon.Source = "--[[ icon:header\n[themes]: https://1foreverhd.github.io/TopbarPlus/features/#themes\n[set method]: https://1foreverhd.github.io/TopbarPlus/api/icon/#set\n\n## Constructors\n\n#### new\n```lua\nlocal icon = Icon.new()\n```\nConstructs an empty ``32x32`` icon on the topbar.\n\n----\n\n\n\n## Methods\n\n#### set\n{chainable}\n```lua\nicon:set(settingName, value, iconState)\n```\nApplies a specific setting to an icon. All settings can be found [here](https://github.com/1ForeverHD/TopbarPlus/blob/main/src/Icon/Themes/Default.lua). If the setting falls under the 'toggleable' category then an iconState can be specified. For most scenarious it's recommended instead to apply settings using [themes].\n\n----\n#### get\n```lua\nlocal value = icon:get(settingName, iconState)\n```\nRetrieves the given settings value. If the setting falls under the 'toggleable' category then an iconState can be specified.\n\n----\n#### getToggleState\n```lua\nlocal selectedOrDeselectedString = icon:getToggleState()\n```\nReturns the current toggleState, either \"deselected\" or \"selected\".\n\n----\n#### setTheme\n{chainable}\n```lua\nicon:setTheme(theme)\n```\nApplies a theme to the given icon. See [themes] for more information.\n\n----\n#### setEnabled\n{chainable}\n```lua\nicon:setEnabled(bool)\n```\nWhen set to ``false``, the icon will be disabled and hidden.\n\n----\n#### setName\n{chainable}\n```lua\nicon:setName(string)\n```\nAssociates the given name to the icon which enables it to be retrieved with ``IconController.getIcon(name)``.\n\n----\n#### setProperty\n{chainable}\n```lua\nicon:setProperty(propertyName, value)\n```\nAn alternative way of doing ``zone[propertyName] = value``. This enables the easy-configuration of icon properties within chained methods.\n\n----\n#### select\n{chainable}\n```lua\nicon:select()\n```\nSelects the icon (as if it were clicked once).\n\n----\n#### deselect\n{chainable}\n```lua\nicon:deselect()\n```\nDeselects the icon (as if it were clicked, then clicked again).\n\n----\n#### notify\n{chainable}\n```lua\nicon:notify(clearNoticeEvent)\n```\nPrompts a notice bubble which accumulates the further it is prompted. If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.\n\n----\n#### clearNotices\n{chainable}\n```lua\nicon:clearNotices()\n```\n\n----\n#### disableStateOverlay\n{chainable}\n```lua\nicon:disableStateOverlay(bool)\n```\nWhen set to ``true``, disables the shade effect which appears when the icon is pressed and released.\n\n----\n#### convertLabelToNumberSpinner\n{chainable}\n```lua\nicon:convertLabelToNumberSpinner(numberSpinner)\n```\nTakes a [NumberSpinner](https://devforum.roblox.com/t/numberspinner-module/1105961) object (by boatbomber) and converts it into the icons label.\n\nExample usage:\n\n```lua\nIcon.new()\n    :setName(\"CashSpinnerIcon\")\n    :setRight()\n    :lock()\n    :setSize(100, 32)\n    :give(function(icon)\n        local NumberSpinner = require(replicatedStorage.NumberSpinner)\n        local labelSpinner = NumberSpinner.new()\n        icon:convertLabelToNumberSpinner(labelSpinner)\n        labelSpinner.Name = \"LabelSpinner\"\n        labelSpinner.Decimals = 3\n        labelSpinner.Duration = 0.25\n        coroutine.wrap(function()\n            while wait(0.5) do\n                labelSpinner.Value = math.random(100000)/1000\n            end\n        end)()\n    end)\n```\n\n----\n#### setImage\n{chainable} {toggleable}\n```lua\nicon:setImage(imageId, iconState)\n```\nApplies an image to the icon based on the given ``imaageId``. ``imageId`` can be an assetId or a complete asset string.\n\n----\n#### setLabel\n{chainable} {toggleable}\n```lua\nicon:setLabel(text, iconState)\n```\n\n----\n#### setOrder\n{chainable} {toggleable}\n```lua\nicon:setOrder(order, iconState)\n```\n\n----\n#### setCornerRadius\n{chainable} {toggleable}\n```lua\nicon:setCornerRadius(scale, offset, iconState)\n```\n\n----\n#### setLeft\n{chainable} {toggleable}\n```lua\nicon:setLeft(iconState)\n```\n\n----\n#### setMid\n{chainable} {toggleable}\n```lua\nicon:setMid(iconState)\n```\n\n----\n#### setRight\n{chainable} {toggleable}\n```lua\nicon:setRight(iconState)\n```\n\n----\n#### setImageYScale\n{chainable} {toggleable}\n```lua\nicon:setImageYScale(YScale, iconState)\n```\nDefines the proportional space the icons image takes up within the icons container.\n\n----\n#### setImageRatio\n{chainable} {toggleable}\n```lua\nicon:setImageRatio(ratio, iconState)\n```\nDefines the x:y ratio dimensions as a number. By default ``ratio`` is ``1.00``.\n\n----\n#### setLabelYScale\n{chainable} {toggleable}\n```lua\nicon:setLabelYScale(YScale, iconState)\n```\nDefines how large label text appears.By default ``YScale`` is ``0.45``.\n\n----\n#### setBaseZIndex\n{chainable} {toggleable}\n```lua\nicon:setBaseZIndex(ZIndex, iconState)\n```\nCalculates the difference between the existing baseZIndex (i.e. ``instances.iconContainer.ZIndex``) and new value, then updates the ZIndex of all objects within the icon accoridngly using this difference.\n\n----\n#### setSize\n{chainable} {toggleable}\n```lua\nicon:setSize(XOffset, YOffset, iconState)\n```\nDetermines the icons container size. By default ``XOffset`` and ``YOffset`` are ``32``.\n\n----\n#### bindToggleItem\n{chainable}\n```lua\nicon:bindToggleItem(guiObjectOrLayerCollector)\n```\nBinds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.\n\n----\n#### unbindToggleItem\n{chainable}\n```lua\nicon:unbindToggleItem(guiObjectOrLayerCollector)\n```\nUnbinds the given GuiObject or LayerCollector from the toggle.\n\n----\n#### bindEvent\n{chainable}\n```lua\nicon:bindEvent(iconEventName, eventFunction)\n```\nConnects to an [icon event](https://1foreverhd.github.io/TopbarPlus/api/icon/#events) based upon the given ``iconEventName`` and call ``eventFunction`` with arguments ``(self, ...)`` when the event is triggered.\n\n----\n#### unbindEvent\n{chainable}\n```lua\nicon:unbindEvent(iconEventName)\n```\nUnbinds the connection of the associated ``iconEventName``.\n\n----\n#### bindToggleKey\n{chainable}\n```lua\nicon:bindToggleKey(keyCodeEnum)\n```\nBinds a [keycode](https://developer.roblox.com/en-us/api-reference/enum/KeyCode) which toggles the icon when pressed.\n\n----\n#### unbindToggleKey\n{chainable}\n```lua\nicon:unbindToggleKey(keyCodeEnum)\n```\nUnbinds the given keycode.\n\n----\n#### give\n{chainable}\n```lua\nicon:give(userdata)\n```\nPasses the given userdata to the Icons maid to be destroyed/disconnected on the icons destruction. If a function is passed, it will be executed right away with its self (the icon) being passed as the first argument. The return value is then given to the maid (instead of the function).\n\n----\n#### lock\n{chainable}\n```lua\nicon:lock()\n```\nPrevents the icon from being pressed and toggled.\n\n----\n#### unlock\n{chainable}\n```lua\nicon:unlock()\n```\nEnables the icon to be pressed and toggled.\n\n----\n#### setTopPadding\n{chainable}\n```lua\nicon:setTopPadding(offset, scale)\n```\nThe gap between the top of the screen and the icon.\n\n----\n#### setTip\n{chainable}\n```lua\nicon:setTip(text)\n```\nSets a tip. To remove, pass ``nil`` as ``text``.\n\n----\n#### setCaption\n{chainable}\n```lua\nicon:setCaption(text)\n```\nSets a caption. To remove, pass ``nil`` as ``text``.\n\n----\n#### join\n{chainable}\n```lua\nicon:join(parentIcon, featureName)\n```\nParents the icon to the given parentIcon under the specified feature, either \"dropdown\" or \"menu\".\n\n----\n#### leave\n{chainable}\n```lua\nicon:leave()\n```\nUnparents an icon from a parentIcon if it belongs to a dropdown or menu.\n\n----\n#### setDropdown\n{chainable}\n```lua\nicon:setDropdown(arrayOfIcons)\n```\nCreates a vertical dropdown based upon the given ``table array`` of ``icons``. Pass an empty table ``{}`` to remove the dropdown. Dropdown settings can be configured using [themes] or the [set method].\n\n----\n#### setMenu\n{chainable}\n```lua\nicon:setMenu(arrayOfIcons)\n```\nCreates a horizontal menu based upon the given ``table array`` of ``icons``. Pass an empty table ``{}`` to remove the menu. Menu settings can be configured using [themes] or the [set method].\n\n----\n#### destroy\n{chainable}\n```lua\nicon:destroy()\n```\nClears all connections and destroys all instances associated with the icon.\n\n----\n\n\n\n## Events\n#### selected \n```lua\nicon.selected:Connect(function()\n    print(\"The icon was selected\")\nend)\n```\n\n----\n#### deselected \n```lua\nicon.deselected:Connect(function()\n    print(\"The icon was deselected\")\nend)\n```\n\n----\n#### toggled \n```lua\nicon.toggled:Connect(function(isSelected)\n    print((\"The icon was %s\"):format(icon:getToggleState(isSelected)))\nend)\n```\n\n----\n#### hoverStarted \n```lua\nicon.hoverStarted:Connect(function()\n    print(\"A mouse, finger or controller selection is hovering over the icon\")\nend)\n```\n\n----\n#### hoverEnded \n```lua\nicon.hoverEnded:Connect(function()\n    print(\"The item is no longer hovering over the icon\")\nend)\n```\n\n----\n#### dropdownOpened \n```lua\nicon.dropdownOpened:Connect(function()\n    print(\"The dropdown was opened\")\nend)\n```\n\n----\n#### dropdownClosed \n```lua\nicon.dropdownClosed:Connect(function()\n    print(\"The dropdown was closed\")\nend)\n```\n\n----\n#### menuOpened \n```lua\nicon.menuOpened:Connect(function()\n    print(\"The menu was opened\")\nend)\n```\n\n----\n#### menuClosed \n```lua\nicon.menuClosed:Connect(function()\n    print(\"The menu was closed\")\nend)\n```\n\n----\n#### notified \n```lua\nicon.notified:Connect(function()\n    print(\"New notice\")\nend)\n```\n\n----\n\n\n\n## Properties\n#### deselectWhenOtherIconSelected\n```lua\nlocal bool = icon.deselectWhenOtherIconSelected --[default: 'true']\n```\nA bool deciding whether the icon will be deselected when another icon is selected. Defaults to ``true``.\n\n----\n#### accountForWhenDisabled\n```lua\nlocal bool = icon.accountForWhenDisabled --[default: 'false']\n```\nA bool deciding whether to continue accounting for and updating the icons position on the topbar when disabled\n\n----\n#### name\n{read-only}\n```lua\nlocal string = icon.name --[default: '\"Unnamed Icon\"']\n```\n\n----\n#### isSelected\n{read-only}\n```lua\nlocal bool = icon.isSelected\n```\n\n----\n#### enabled\n{read-only}\n```lua\nlocal bool = icon.enabled\n```\n\n----\n#### hovering\n{read-only}\n```lua\nlocal bool = icon.hovering\n```\n\n----\n#### tipText\n{read-only}\n```lua\nlocal stringOrNil = icon.tipText\n```\n\n----\n#### captionText\n{read-only}\n```lua\nlocal stringOrNil = icon.captionText\n```\n\n----\n#### totalNotices\n{read-only}\n```lua\nlocal int = icon.totalNotices\n```\n\n----\n#### dropdownIcons\n{read-only}\n```lua\nlocal arrayOfIcons = icon.dropdownIcons\n```\n\n----\n#### menuIcons\n{read-only}\n```lua\nlocal arrayOfIcons = icon.menuIcons\n```\n\n----\n#### dropdownOpen\n{read-only}\n```lua\nlocal bool = icon.dropdownOpen\n```\n\n----\n#### menuOpen\n{read-only}\n```lua\nlocal bool = icon.menuOpen\n```\n\n----\n#### locked\n{read-only}\n```lua\nlocal bool = icon.locked\n```\n\n----\n#### topPadding\n{read-only}\n```lua\nlocal udim = icon.topPadding\n```\n\n----\n#### targetPosition\n{read-only}\n```lua\nlocal udim2 = icon.targetPosition\n```\nThe position the icon is at or aims to move to.\n--]]\n\n\n\n-- LOCAL\nlocal tweenService = game:GetService(\"TweenService\")\nlocal replicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal debris = game:GetService(\"Debris\")\nlocal userInputService = game:GetService(\"UserInputService\")\nlocal httpService = game:GetService(\"HttpService\") -- This is to generate GUIDs\nlocal runService = game:GetService(\"RunService\")\nlocal textService = game:GetService(\"TextService\")\nlocal guiService = game:GetService(\"GuiService\")\nlocal starterGui = game:GetService(\"StarterGui\")\nlocal players = game:GetService(\"Players\")\nlocal IconController = require(script.IconController)\nlocal Signal = require(script.Signal)\nlocal Maid = require(script.Maid)\nlocal TopbarPlusGui = require(script.TopbarPlusGui)\nlocal TopbarPlusReference = require(script.TopbarPlusReference)\nlocal referenceObject = TopbarPlusReference.getObject()\nlocal Themes = require(script.Themes)\nlocal activeItems = TopbarPlusGui.ActiveItems\nlocal topbarContainer = TopbarPlusGui.TopbarContainer\nlocal iconTemplate = topbarContainer[\"IconContainer\"]\nlocal DEFAULT_THEME = Themes.Default\nlocal THUMB_OFFSET = 55\nlocal DEFAULT_FORCED_GROUP_VALUES = {}\nlocal Icon = (referenceObject and require(referenceObject.Value)) or {}\nIcon.__index = Icon\nif not referenceObject then\n\tTopbarPlusReference.addToReplicatedStorage()\nend\n\n\n\n-- CONSTRUCTORS\nfunction Icon.new()\n\tlocal self = {}\n\tsetmetatable(self, Icon)\n\n\t-- Maids (for autocleanup)\n\tlocal maid = Maid.new()\n\tself._maid = maid\n\tself._hoveringMaid = maid:give(Maid.new())\n\tself._dropdownClippingMaid = maid:give(Maid.new())\n\tself._menuClippingMaid = maid:give(Maid.new())\n\n\t-- These are the GuiObjects that make up the icon\n\tlocal instances = {}\n\tself.instances = instances\n\tlocal iconContainer = maid:give(iconTemplate:Clone())\n\ticonContainer.Visible = true\n\ticonContainer.Parent = topbarContainer\n\tinstances[\"iconContainer\"] = iconContainer\n\tinstances[\"iconButton\"] = iconContainer.IconButton\n\tinstances[\"iconImage\"] = instances.iconButton.IconImage\n\tinstances[\"iconLabel\"] = instances.iconButton.IconLabel\n\tinstances[\"iconGradient\"] = instances.iconButton.IconGradient\n\tinstances[\"iconCorner\"] = instances.iconButton.IconCorner\n\tinstances[\"iconOverlay\"] = iconContainer.IconOverlay\n\tinstances[\"iconOverlayCorner\"] = instances.iconOverlay.IconOverlayCorner\n\tinstances[\"noticeFrame\"] = instances.iconButton.NoticeFrame\n\tinstances[\"noticeLabel\"] = instances.noticeFrame.NoticeLabel\n\tinstances[\"captionContainer\"] = iconContainer.CaptionContainer\n\tinstances[\"captionFrame\"] = instances.captionContainer.CaptionFrame\n\tinstances[\"captionLabel\"] = instances.captionContainer.CaptionLabel\n\tinstances[\"captionCorner\"] = instances.captionFrame.CaptionCorner\n\tinstances[\"captionOverlineContainer\"] = instances.captionContainer.CaptionOverlineContainer\n\tinstances[\"captionOverline\"] = instances.captionOverlineContainer.CaptionOverline\n\tinstances[\"captionOverlineCorner\"] = instances.captionOverline.CaptionOverlineCorner\n\tinstances[\"captionVisibilityBlocker\"] = instances.captionFrame.CaptionVisibilityBlocker\n\tinstances[\"captionVisibilityCorner\"] = instances.captionVisibilityBlocker.CaptionVisibilityCorner\n\tinstances[\"tipFrame\"] = iconContainer.TipFrame\n\tinstances[\"tipLabel\"] = instances.tipFrame.TipLabel\n\tinstances[\"tipCorner\"] = instances.tipFrame.TipCorner\n\tinstances[\"dropdownContainer\"] = iconContainer.DropdownContainer\n\tinstances[\"dropdownFrame\"] = instances.dropdownContainer.DropdownFrame\n\tinstances[\"dropdownList\"] = instances.dropdownFrame.DropdownList\n\tinstances[\"menuContainer\"] = iconContainer.MenuContainer\n\tinstances[\"menuFrame\"] = instances.menuContainer.MenuFrame\n\tinstances[\"menuList\"] = instances.menuFrame.MenuList\n\tinstances[\"clickSound\"] = iconContainer.ClickSound\n\n\t-- These determine and describe how instances behave and appear\n\tself._settings = {\n\t\taction = {\n\t\t\t[\"toggleTransitionInfo\"] = {},\n\t\t\t[\"resizeInfo\"] = {},\n\t\t\t[\"repositionInfo\"] = {},\n\t\t\t[\"captionFadeInfo\"] = {},\n\t\t\t[\"tipFadeInfo\"] = {},\n\t\t\t[\"dropdownSlideInfo\"] = {},\n\t\t\t[\"menuSlideInfo\"] = {},\n\t\t},\n\t\ttoggleable = {\n\t\t\t[\"iconBackgroundColor\"] = {instanceNames = {\"iconButton\"}, propertyName = \"BackgroundColor3\"},\n\t\t\t[\"iconBackgroundTransparency\"] = {instanceNames = {\"iconButton\"}, propertyName = \"BackgroundTransparency\"},\n\t\t\t[\"iconCornerRadius\"] = {instanceNames = {\"iconCorner\", \"iconOverlayCorner\"}, propertyName = \"CornerRadius\"},\n\t\t\t[\"iconGradientColor\"] = {instanceNames = {\"iconGradient\"}, propertyName = \"Color\"},\n\t\t\t[\"iconGradientRotation\"] = {instanceNames = {\"iconGradient\"}, propertyName = \"Rotation\"},\n\t\t\t[\"iconImage\"] = {callMethods = {self._updateIconSize}, instanceNames = {\"iconImage\"}, propertyName = \"Image\"},\n\t\t\t[\"iconImageColor\"] = {instanceNames = {\"iconImage\"}, propertyName = \"ImageColor3\"},\n\t\t\t[\"iconImageTransparency\"] = {instanceNames = {\"iconImage\"}, propertyName = \"ImageTransparency\"},\n\t\t\t[\"iconScale\"] = {instanceNames = {\"iconButton\"}, propertyName = \"Size\"},\n\t\t\t[\"forcedIconSize\"] = {},\n\t\t\t[\"iconSize\"] = {callSignals = {self.updated}, callMethods = {self._updateIconSize}, instanceNames = {\"iconContainer\"}, propertyName = \"Size\", tweenAction = \"resizeInfo\"},\n\t\t\t[\"iconOffset\"] = {instanceNames = {\"iconButton\"}, propertyName = \"Position\"},\n\t\t\t[\"iconText\"] = {callMethods = {self._updateIconSize}, instanceNames = {\"iconLabel\"}, propertyName = \"Text\"},\n\t\t\t[\"iconTextColor\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"TextColor3\"},\n\t\t\t[\"iconFont\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"Font\"},\n\t\t\t[\"iconImageYScale\"] = {callMethods = {self._updateIconSize}},\n\t\t\t[\"iconImageRatio\"] = {callMethods = {self._updateIconSize}},\n\t\t\t[\"iconLabelYScale\"] = {callMethods = {self._updateIconSize}},\n\t\t\t[\"noticeCircleColor\"] = {instanceNames = {\"noticeFrame\"}, propertyName = \"ImageColor3\"},\n\t\t\t[\"noticeCircleImage\"] = {instanceNames = {\"noticeFrame\"}, propertyName = \"Image\"},\n\t\t\t[\"noticeTextColor\"] = {instanceNames = {\"noticeLabel\"}, propertyName = \"TextColor3\"},\n\t\t\t[\"noticeImageTransparency\"] = {instanceNames = {\"noticeFrame\"}, propertyName = \"ImageTransparency\"},\n\t\t\t[\"noticeTextTransparency\"] = {instanceNames = {\"noticeLabel\"}, propertyName = \"TextTransparency\"},\n\t\t\t[\"baseZIndex\"] = {callMethods = {self._updateBaseZIndex}},\n\t\t\t[\"order\"] = {callSignals = {self.updated}, instanceNames = {\"iconContainer\"}, propertyName = \"LayoutOrder\"},\n\t\t\t[\"alignment\"] = {callSignals = {self.updated}, callMethods = {self._updateDropdown}},\n\t\t\t[\"iconImageVisible\"] = {instanceNames = {\"iconImage\"}, propertyName = \"Visible\"},\n\t\t\t[\"iconImageAnchorPoint\"] = {instanceNames = {\"iconImage\"}, propertyName = \"AnchorPoint\"},\n\t\t\t[\"iconImagePosition\"] = {instanceNames = {\"iconImage\"}, propertyName = \"Position\", tweenAction = \"resizeInfo\"},\n\t\t\t[\"iconImageSize\"] = {instanceNames = {\"iconImage\"}, propertyName = \"Size\", tweenAction = \"resizeInfo\"},\n\t\t\t[\"iconImageTextXAlignment\"] = {instanceNames = {\"iconImage\"}, propertyName = \"TextXAlignment\"},\n\t\t\t[\"iconLabelVisible\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"Visible\"},\n\t\t\t[\"iconLabelAnchorPoint\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"AnchorPoint\"},\n\t\t\t[\"iconLabelPosition\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"Position\", tweenAction = \"resizeInfo\"},\n\t\t\t[\"iconLabelSize\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"Size\", tweenAction = \"resizeInfo\"},\n\t\t\t[\"iconLabelTextXAlignment\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"TextXAlignment\"},\n\t\t\t[\"iconLabelTextSize\"] = {instanceNames = {\"iconLabel\"}, propertyName = \"TextSize\"},\n\t\t\t[\"noticeFramePosition\"] = {instanceNames = {\"noticeFrame\"}, propertyName = \"Position\"},\n\t\t\t[\"clickSoundId\"] = {instanceNames = {\"clickSound\"}, propertyName = \"SoundId\"},\n\t\t\t[\"clickVolume\"] = {instanceNames = {\"clickSound\"}, propertyName = \"Volume\"},\n\t\t\t[\"clickPlaybackSpeed\"] = {instanceNames = {\"clickSound\"}, propertyName = \"PlaybackSpeed\"},\n\t\t\t[\"clickTimePosition\"] = {instanceNames = {\"clickSound\"}, propertyName = \"TimePosition\"},\n\t\t},\n\t\tother = {\n\t\t\t[\"captionBackgroundColor\"] = {instanceNames = {\"captionFrame\"}, propertyName = \"BackgroundColor3\"},\n\t\t\t[\"captionBackgroundTransparency\"] = {instanceNames = {\"captionFrame\"}, propertyName = \"BackgroundTransparency\", group = \"caption\"},\n\t\t\t[\"captionBlockerTransparency\"] = {instanceNames = {\"captionVisibilityBlocker\"}, propertyName = \"BackgroundTransparency\", group = \"caption\"},\n\t\t\t[\"captionOverlineColor\"] = {instanceNames = {\"captionOverline\"}, propertyName = \"BackgroundColor3\"},\n\t\t\t[\"captionOverlineTransparency\"] = {instanceNames = {\"captionOverline\"}, propertyName = \"BackgroundTransparency\", group = \"caption\"},\n\t\t\t[\"captionTextColor\"] = {instanceNames = {\"captionLabel\"}, propertyName = \"TextColor3\"},\n\t\t\t[\"captionTextTransparency\"] = {instanceNames = {\"captionLabel\"}, propertyName = \"TextTransparency\", group = \"caption\"},\n\t\t\t[\"captionFont\"] = {instanceNames = {\"captionLabel\"}, propertyName = \"Font\"},\n\t\t\t[\"captionCornerRadius\"] = {instanceNames = {\"captionCorner\", \"captionOverlineCorner\", \"captionVisibilityCorner\"}, propertyName = \"CornerRadius\"},\n\t\t\t[\"tipBackgroundColor\"] = {instanceNames = {\"tipFrame\"}, propertyName = \"BackgroundColor3\"},\n\t\t\t[\"tipBackgroundTransparency\"] = {instanceNames = {\"tipFrame\"}, propertyName = \"BackgroundTransparency\", group = \"tip\"},\n\t\t\t[\"tipTextColor\"] = {instanceNames = {\"tipLabel\"}, propertyName = \"TextColor3\"},\n\t\t\t[\"tipTextTransparency\"] = {instanceNames = {\"tipLabel\"}, propertyName = \"TextTransparency\", group = \"tip\"},\n\t\t\t[\"tipFont\"] = {instanceNames = {\"tipLabel\"}, propertyName = \"Font\"},\n\t\t\t[\"tipCornerRadius\"] = {instanceNames = {\"tipCorner\"}, propertyName = \"CornerRadius\"},\n\t\t\t[\"dropdownSize\"] = {instanceNames = {\"dropdownContainer\"}, propertyName = \"Size\", unique = \"dropdown\"},\n\t\t\t[\"dropdownCanvasSize\"] = {instanceNames = {\"dropdownFrame\"}, propertyName = \"CanvasSize\"},\n\t\t\t[\"dropdownMaxIconsBeforeScroll\"] = {callMethods = {self._updateDropdown}},\n\t\t\t[\"dropdownMinWidth\"] = {callMethods = {self._updateDropdown}},\n\t\t\t[\"dropdownSquareCorners\"] = {callMethods = {self._updateDropdown}},\n\t\t\t[\"dropdownBindToggleToIcon\"] = {},\n\t\t\t[\"dropdownToggleOnLongPress\"] = {},\n\t\t\t[\"dropdownToggleOnRightClick\"] = {},\n\t\t\t[\"dropdownCloseOnTapAway\"] = {},\n\t\t\t[\"dropdownHidePlayerlistOnOverlap\"] = {},\n\t\t\t[\"dropdownListPadding\"] = {callMethods = {self._updateDropdown}, instanceNames = {\"dropdownList\"}, propertyName = \"Padding\"},\n\t\t\t[\"dropdownAlignment\"] = {callMethods = {self._updateDropdown}},\n\t\t\t[\"dropdownScrollBarColor\"] = {instanceNames = {\"dropdownFrame\"}, propertyName = \"ScrollBarImageColor3\"},\n\t\t\t[\"dropdownScrollBarTransparency\"] = {instanceNames = {\"dropdownFrame\"}, propertyName = \"ScrollBarImageTransparency\"},\n\t\t\t[\"dropdownScrollBarThickness\"] = {instanceNames = {\"dropdownFrame\"}, propertyName = \"ScrollBarThickness\"},\n\t\t\t[\"dropdownIgnoreClipping\"] = {callMethods = {self._dropdownIgnoreClipping}},\n\t\t\t[\"menuSize\"] = {instanceNames = {\"menuContainer\"}, propertyName = \"Size\", unique = \"menu\"},\n\t\t\t[\"menuCanvasSize\"] = {instanceNames = {\"menuFrame\"}, propertyName = \"CanvasSize\"},\n\t\t\t[\"menuMaxIconsBeforeScroll\"] = {callMethods = {self._updateMenu}},\n\t\t\t[\"menuBindToggleToIcon\"] = {},\n\t\t\t[\"menuToggleOnLongPress\"] = {},\n\t\t\t[\"menuToggleOnRightClick\"] = {},\n\t\t\t[\"menuCloseOnTapAway\"] = {},\n\t\t\t[\"menuListPadding\"] = {callMethods = {self._updateMenu}, instanceNames = {\"menuList\"}, propertyName = \"Padding\"},\n\t\t\t[\"menuDirection\"] = {callMethods = {self._updateMenu}},\n\t\t\t[\"menuScrollBarColor\"] = {instanceNames = {\"menuFrame\"}, propertyName = \"ScrollBarImageColor3\"},\n\t\t\t[\"menuScrollBarTransparency\"] = {instanceNames = {\"menuFrame\"}, propertyName = \"ScrollBarImageTransparency\"},\n\t\t\t[\"menuScrollBarThickness\"] = {instanceNames = {\"menuFrame\"}, propertyName = \"ScrollBarThickness\"},\n\t\t\t[\"menuIgnoreClipping\"] = {callMethods = {self._menuIgnoreClipping}},\n\t\t}\n\t}\n\n\t---------------------------------\n\tself._groupSettings = {}\n\tfor _, settingsDetails in pairs(self._settings) do\n\t\tfor settingName, settingDetail in pairs(settingsDetails) do\n\t\t\tlocal group = settingDetail.group\n\t\t\tif group then\n\t\t\t\tlocal groupSettings = self._groupSettings[group]\n\t\t\t\tif not groupSettings then\n\t\t\t\t\tgroupSettings = {}\n\t\t\t\t\tself._groupSettings[group] = groupSettings\n\t\t\t\tend\n\t\t\t\ttable.insert(groupSettings, settingName)\n\t\t\t\tsettingDetail.forcedGroupValue = DEFAULT_FORCED_GROUP_VALUES[group]\n\t\t\t\tsettingDetail.useForcedGroupValue = true\n\t\t\tend\n\t\tend\n\tend\n\t---------------------------------\n\n\t-- The setting values themselves will be set within _settings\n\t-- Setup a dictionary to make it quick and easy to reference setting by name\n\tself._settingsDictionary = {}\n\t-- Some instances require unique behaviours. These are defined with the 'unique' key\n\t-- for instance, we only want caption transparency effects to be applied on hovering\n\tself._uniqueSettings = {}\n\tself._uniqueSettingsDictionary = {}\n\tself.uniqueValues = {}\n\tlocal uniqueBehaviours = {\n\t\t[\"dropdown\"] = function(settingName, instance, propertyName, value)\n\t\t\tlocal tweenInfo = self:get(\"dropdownSlideInfo\")\n\t\t\tlocal bindToggleToIcon = self:get(\"dropdownBindToggleToIcon\")\n\t\t\tlocal hidePlayerlist = self:get(\"dropdownHidePlayerlistOnOverlap\") == true and self:get(\"alignment\") == \"right\"\n\t\t\tlocal dropdownContainer = self.instances.dropdownContainer\n\t\t\tlocal dropdownFrame = self.instances.dropdownFrame\n\t\t\tlocal newValue = value\n\t\t\tlocal isOpen = true\n\t\t\tlocal isDeselected = not self.isSelected\n\t\t\tif bindToggleToIcon == false then\n\t\t\t\tisDeselected = not self.dropdownOpen\n\t\t\tend\n\t\t\tlocal isSpecialPressing = self._longPressing or self._rightClicking\n\t\t\tif self._tappingAway or (isDeselected and not isSpecialPressing) or (isSpecialPressing and self.dropdownOpen) then \n\t\t\t\tlocal dropdownSize = self:get(\"dropdownSize\")\n\t\t\t\tlocal XOffset = (dropdownSize and dropdownSize.X.Offset/1) or 0\n\t\t\t\tnewValue = UDim2.new(0, XOffset, 0, 0)\n\t\t\t\tisOpen = false\n\t\t\tend\n\t\t\tif #self.dropdownIcons > 0 and isOpen and hidePlayerlist then\n\t\t\t\tif starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList) then\n\t\t\t\t\tstarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)\n\t\t\t\tend\n\t\t\t\tIconController._bringBackPlayerlist = (IconController._bringBackPlayerlist and IconController._bringBackPlayerlist + 1) or 1\n\t\t\t\tself._bringBackPlayerlist = true\n\t\t\telseif self._bringBackPlayerlist and not isOpen and IconController._bringBackPlayerlist then\n\t\t\t\tIconController._bringBackPlayerlist -= 1\n\t\t\t\tif IconController._bringBackPlayerlist <= 0 then\n\t\t\t\t\tIconController._bringBackPlayerlist = nil\n\t\t\t\t\tstarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)\n\t\t\t\tend\n\t\t\t\tself._bringBackPlayerlist = nil\n\t\t\tend\n\t\t\tlocal tween = tweenService:Create(instance, tweenInfo, {[propertyName] = newValue})\n\t\t\tlocal connection\n\t\t\tconnection = tween.Completed:Connect(function()\n\t\t\t\tconnection:Disconnect()\n\t\t\t\t--dropdownContainer.ClipsDescendants = not self.dropdownOpen\n\t\t\tend)\n\t\t\ttween:Play()\n\t\t\tif isOpen then\n\t\t\t\tdropdownFrame.CanvasPosition = self._dropdownCanvasPos\n\t\t\telse\n\t\t\t\tself._dropdownCanvasPos = dropdownFrame.CanvasPosition\n\t\t\tend\n\t\t\tself.dropdownOpen = isOpen\n\t\t\tself:_decideToCallSignal(\"dropdown\")\n\t\tend,\n\t\t[\"menu\"] = function(settingName, instance, propertyName, value)\n\t\t\tlocal tweenInfo = self:get(\"menuSlideInfo\")\n\t\t\tlocal bindToggleToIcon = self:get(\"menuBindToggleToIcon\")\n\t\t\tlocal menuContainer = self.instances.menuContainer\n\t\t\tlocal menuFrame = self.instances.menuFrame\n\t\t\tlocal newValue = value\n\t\t\tlocal isOpen = true\n\t\t\tlocal isDeselected = not self.isSelected\n\t\t\tif bindToggleToIcon == false then\n\t\t\t\tisDeselected = not self.menuOpen\n\t\t\tend\n\t\t\tlocal isSpecialPressing = self._longPressing or self._rightClicking\n\t\t\tif self._tappingAway or (isDeselected and not isSpecialPressing) or (isSpecialPressing and self.menuOpen) then \n\t\t\t\tlocal menuSize = self:get(\"menuSize\")\n\t\t\t\tlocal YOffset = (menuSize and menuSize.Y.Offset/1) or 0\n\t\t\t\tnewValue = UDim2.new(0, 0, 0, YOffset)\n\t\t\t\tisOpen = false\n\t\t\tend\n\t\t\tif isOpen ~= self.menuOpen then\n\t\t\t\tself.updated:Fire()\n\t\t\tend\n\t\t\tif isOpen and tweenInfo.EasingDirection == Enum.EasingDirection.Out then\n\t\t\t\ttweenInfo = TweenInfo.new(tweenInfo.Time, tweenInfo.EasingStyle, Enum.EasingDirection.In)\n\t\t\tend\n\t\t\tlocal tween = tweenService:Create(instance, tweenInfo, {[propertyName] = newValue})\n\t\t\tlocal connection\n\t\t\tconnection = tween.Completed:Connect(function()\n\t\t\t\tconnection:Disconnect()\n\t\t\t\t--menuContainer.ClipsDescendants = not self.menuOpen\n\t\t\tend)\n\t\t\ttween:Play()\n\t\t\tif isOpen then\n\t\t\t\tif self._menuCanvasPos then\n\t\t\t\t\tmenuFrame.CanvasPosition = self._menuCanvasPos\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tself._menuCanvasPos = menuFrame.CanvasPosition\n\t\t\tend\n\t\t\tself.menuOpen = isOpen\n\t\t\tself:_decideToCallSignal(\"menu\")\n\t\tend,\n\t}\n\tfor settingsType, settingsDetails in pairs(self._settings) do\n\t\tfor settingName, settingDetail in pairs(settingsDetails) do\n\t\t\tif settingsType == \"toggleable\" then\n\t\t\t\tsettingDetail.values = settingDetail.values or {\n\t\t\t\t\tdeselected = nil,\n\t\t\t\t\tselected = nil,\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tsettingDetail.value = nil\n\t\t\tend\n\t\t\tsettingDetail.additionalValues = {}\n\t\t\tsettingDetail.type = settingsType\n\t\t\tself._settingsDictionary[settingName] = settingDetail\n\t\t\t--\n\t\t\tlocal uniqueCat = settingDetail.unique\n\t\t\tif uniqueCat then\n\t\t\t\tlocal uniqueCatArray = self._uniqueSettings[uniqueCat] or {}\n\t\t\t\ttable.insert(uniqueCatArray, settingName)\n\t\t\t\tself._uniqueSettings[uniqueCat] = uniqueCatArray\n\t\t\t\tself._uniqueSettingsDictionary[settingName] = uniqueBehaviours[uniqueCat]\n\t\t\tend\n\t\t\t--\n\t\tend\n\tend\n\t\n\t-- Signals (events)\n\tself.updated = maid:give(Signal.new())\n\tself.selected = maid:give(Signal.new())\n    self.deselected = maid:give(Signal.new())\n    self.toggled = maid:give(Signal.new())\n\tself.hoverStarted = maid:give(Signal.new())\n\tself.hoverEnded = maid:give(Signal.new())\n\tself.dropdownOpened = maid:give(Signal.new())\n\tself.dropdownClosed = maid:give(Signal.new())\n\tself.menuOpened = maid:give(Signal.new())\n\tself.menuClosed = maid:give(Signal.new())\n\tself.notified = maid:give(Signal.new())\n\tself._endNotices = maid:give(Signal.new())\n\tself._ignoreClippingChanged = maid:give(Signal.new())\n\t\n\t-- Connections\n\t-- This enables us to chain icons and features like menus and dropdowns together without them being hidden by parent frame with ClipsDescendants enabled\n\tlocal function setFeatureChange(featureName, value)\n\t\tlocal parentIcon = self._parentIcon\n\t\tself:set(featureName..\"IgnoreClipping\", value)\n\t\tif value == true and parentIcon then\n\t\t\tlocal connection = parentIcon._ignoreClippingChanged:Connect(function(_, value)\n\t\t\t\tself:set(featureName..\"IgnoreClipping\", value)\n\t\t\tend)\n\t\t\tlocal endConnection\n\t\t\tendConnection = self[featureName..\"Closed\"]:Connect(function()\n\t\t\t\tendConnection:Disconnect()\n\t\t\t\tconnection:Disconnect()\n\t\t\tend)\n\t\tend\n\tend\n\tself.dropdownOpened:Connect(function()\n\t\tsetFeatureChange(\"dropdown\", true)\n\tend)\n\tself.dropdownClosed:Connect(function()\n\t\tsetFeatureChange(\"dropdown\", false)\n\tend)\n\tself.menuOpened:Connect(function()\n\t\tsetFeatureChange(\"menu\", true)\n\tend)\n\tself.menuClosed:Connect(function()\n\t\tsetFeatureChange(\"menu\", false)\n\tend)\n\t--]]\n\n\t-- Properties\n\tself.deselectWhenOtherIconSelected = true\n\tself.name = \"\"\n\tself.isSelected = false\n\tself.presentOnTopbar = true\n\tself.accountForWhenDisabled = false\n\tself.enabled = true\n\tself.hovering = false\n\tself.tipText = nil\n\tself.captionText = nil\n\tself.totalNotices = 0\n\tself.notices = {}\n\tself.dropdownIcons = {}\n\tself.menuIcons = {}\n\tself.dropdownOpen = false\n\tself.menuOpen = false\n\tself.locked = false\n\tself.topPadding = UDim.new(0, 4)\n\tself.targetPosition = nil\n\tself.toggleItems = {}\n\tself.lockedSettings = {}\n\t\n\t-- Private Properties\n\tself._draggingFinger = false\n\tself._updatingIconSize = true\n\tself._previousDropdownOpen = false\n\tself._previousMenuOpen = false\n\tself._bindedToggleKeys = {}\n\tself._bindedEvents = {}\n\t\n\t-- Apply start values\n\tself:setName(\"UnnamedIcon\")\n\tself:setTheme(DEFAULT_THEME, true)\n\n\t-- Input handlers\n\t-- Calls deselect/select when the icon is clicked\n\t--[[instances.iconButton.MouseButton1Click:Connect(function()\n\t\tif self._draggingFinger then\n\t\t\treturn false\n\t\telseif self.isSelected then\n\t\t\tself:deselect()\n\t\t\treturn true\n\t\tend\n\t\tself:select()\n\tend)--]]\n\tinstances.iconButton.MouseButton1Click:Connect(function()\n\t\tif self.isSelected then\n\t\t\tself:deselect()\n\t\t\treturn true\n\t\tend\n\t\tself:select()\n\tend)\n\tinstances.iconButton.MouseButton2Click:Connect(function()\n\t\tself._rightClicking = true\n\t\tif self:get(\"dropdownToggleOnRightClick\") == true then\n\t\t\tself:_update(\"dropdownSize\")\n\t\tend\n\t\tif self:get(\"menuToggleOnRightClick\") == true then\n\t\t\tself:_update(\"menuSize\")\n\t\tend\n\t\tself._rightClicking = false\n\tend)\n\n\t-- Shows/hides the dark overlay when the icon is presssed/released\n\tinstances.iconButton.MouseButton1Down:Connect(function()\n\t\tif self.locked then return end\n\t\tself:_updateStateOverlay(0.7, Color3.new(0, 0, 0))\n\tend)\n\tinstances.iconButton.MouseButton1Up:Connect(function()\n\t\tif self.locked then return end\n\t\tself:_updateStateOverlay(0.9, Color3.new(1, 1, 1))\n\tend)\n\n\t-- Tap away + KeyCode toggles\n\tuserInputService.InputBegan:Connect(function(input, touchingAnObject)\n\t\tlocal validTapAwayInputs = {\n\t\t\t[Enum.UserInputType.MouseButton1] = true,\n\t\t\t[Enum.UserInputType.MouseButton2] = true,\n\t\t\t[Enum.UserInputType.MouseButton3] = true,\n\t\t\t[Enum.UserInputType.Touch] = true,\n\t\t}\n\t\tif not touchingAnObject and validTapAwayInputs[input.UserInputType] then\n\t\t\tself._tappingAway = true\n\t\t\tif self.dropdownOpen and self:get(\"dropdownCloseOnTapAway\") == true then\n\t\t\t\tself:_update(\"dropdownSize\")\n\t\t\tend\n\t\t\tif self.menuOpen and self:get(\"menuCloseOnTapAway\") == true then\n\t\t\t\tself:_update(\"menuSize\")\n\t\t\tend\n\t\t\tself._tappingAway = false\n\t\tend\n\t\t--\n\t\tif self._bindedToggleKeys[input.KeyCode] and not touchingAnObject then\n\t\t\tif self.isSelected then\n\t\t\t\tself:deselect()\n\t\t\telse\n\t\t\t\tself:select()\n\t\t\tend\n\t\tend\n\t\t--\n\tend)\n\t\n\t-- hoverStarted and hoverEnded triggers and actions\n\t-- these are triggered when a mouse enters/leaves the icon with a mouse, is highlighted with\n\t-- a controller selection box, or dragged over with a touchpad\n\tself.hoverStarted:Connect(function(x, y)\n\t\tself.hovering = true\n\t\tif not self.locked then\n\t\t\tself:_updateStateOverlay(0.9, Color3.fromRGB(255, 255, 255))\n\t\tend\n\t\tself:_updateHovering()\n\tend)\n\tself.hoverEnded:Connect(function()\n\t\tself.hovering = false\n\t\tself:_updateStateOverlay(1)\n\t\tself._hoveringMaid:clean()\n\t\tself:_updateHovering()\n\tend)\n\tinstances.iconButton.MouseEnter:Connect(function(x, y) -- Mouse (started)\n\t\tself.hoverStarted:Fire(x, y)\n\tend)\n\tinstances.iconButton.MouseLeave:Connect(function() -- Mouse (ended)\n\t\tself.hoverEnded:Fire()\n\tend)\n\tinstances.iconButton.SelectionGained:Connect(function() -- Controller (started)\n\t\tself.hoverStarted:Fire()\n\tend)\n\tinstances.iconButton.SelectionLost:Connect(function() -- Controller (ended)\n\t\tself.hoverEnded:Fire()\n\tend)\n\tinstances.iconButton.MouseButton1Down:Connect(function() -- TouchPad (started)\n\t\tif self._draggingFinger then\n\t\t\tself.hoverStarted:Fire()\n\t\tend\n\t\t-- Long press check\n\t\tlocal heartbeatConnection\n\t\tlocal releaseConnection\n\t\tlocal longPressTime = 0.7\n\t\tlocal endTick = tick() + longPressTime\n\t\theartbeatConnection = runService.Heartbeat:Connect(function()\n\t\t\tif tick() >= endTick then\n\t\t\t\treleaseConnection:Disconnect()\n\t\t\t\theartbeatConnection:Disconnect()\n\t\t\t\tself._longPressing = true\n\t\t\t\tif self:get(\"dropdownToggleOnLongPress\") == true then\n\t\t\t\t\tself:_update(\"dropdownSize\")\n\t\t\t\tend\n\t\t\t\tif self:get(\"menuToggleOnLongPress\") == true then\n\t\t\t\t\tself:_update(\"menuSize\")\n\t\t\t\tend\n\t\t\t\tself._longPressing = false\n\t\t\tend\n\t\tend)\n\t\treleaseConnection = instances.iconButton.MouseButton1Up:Connect(function()\n\t\t\treleaseConnection:Disconnect()\n\t\t\theartbeatConnection:Disconnect()\n\t\tend)\n\tend)\n\tif userInputService.TouchEnabled then\n\t\tinstances.iconButton.MouseButton1Up:Connect(function() -- TouchPad (ended), this was originally enabled for non-touchpads too\n\t\t\tif self.hovering then\n\t\t\t\tself.hoverEnded:Fire()\n\t\t\tend\n\t\tend)\n\t\t-- This is used to highlight when a mobile/touch device is dragging their finger accross the screen\n\t\t-- this is important for determining the hoverStarted and hoverEnded events on mobile\n\t\tlocal dragCount = 0\n\t\tuserInputService.TouchMoved:Connect(function(touch, touchingAnObject)\n\t\t\tif touchingAnObject then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tself._draggingFinger = true\n\t\tend)\n\t\tuserInputService.TouchEnded:Connect(function()\n\t\t\tself._draggingFinger = false\n\t\tend)\n\tend\n\n\t-- Finish\n\tself._updatingIconSize = false\n\tself:_updateIconSize()\n\tIconController.iconAdded:Fire(self)\n\t\n\treturn self\nend\n\n-- This is the same as Icon.new(), except it adds additional behaviour for certain specified names designed to mimic core icons, such as 'Chat'\nfunction Icon.mimic(coreIconToMimic)\n\tlocal iconName = coreIconToMimic..\"Mimic\"\n\tlocal icon = IconController.getIcon(iconName)\n\tif icon then\n\t\treturn icon\n\tend\n\ticon = Icon.new()\n\ticon:setName(iconName)\n\n\tif coreIconToMimic == \"Chat\" then\n\t\ticon:setOrder(-1)\n\t\ticon:setImage(\"rbxasset://textures/ui/TopBar/chatOff.png\", \"deselected\")\n\t\ticon:setImage(\"rbxasset://textures/ui/TopBar/chatOn.png\", \"selected\")\n\t\ticon:setImageYScale(0.625)\n\t\t-- Since roblox's core gui api sucks melons I reverted to listening for signals within the chat modules\n\t\t-- unfortunately however they've just gone and removed *these* signals therefore \n\t\t-- this mimic chat and similar features are now impossible to recreate accurately, so I'm disabling for now\n\t\t-- ill go ahead and post a feature request; fingers crossed we get something by the next decade\n\n\t\t--[[\n\t\t-- Setup maid and cleanup actioon\n\t\tlocal maid = icon._maid\n\t\ticon._fakeChatMaid = maid:give(Maid.new())\n\t\tmaid.chatMimicCleanup = function()\n\t\t\tstarterGui:SetCoreGuiEnabled(\"Chat\", icon.enabled)\n\t\tend\n\t\t-- Tap into chat module\n\t\tlocal chatMainModule = players.LocalPlayer.PlayerScripts:WaitForChild(\"ChatScript\").ChatMain\n\t\tlocal ChatMain = require(chatMainModule)\n\t\tlocal function displayChatBar(visibility)\n\t\t\ticon.ignoreVisibilityStateChange = true\n\t\t\tChatMain.CoreGuiEnabled:fire(visibility)\n\t\t\tChatMain.IsCoreGuiEnabled = false\n\t\t\tChatMain:SetVisible(visibility)\n\t\t\ticon.ignoreVisibilityStateChange = nil\n\t\tend\n\t\tlocal function setIconEnabled(visibility)\n\t\t\ticon.ignoreVisibilityStateChange = true\n\t\t\tChatMain.CoreGuiEnabled:fire(visibility)\n\t\t\ticon:setEnabled(visibility)\n\t\t\tstarterGui:SetCoreGuiEnabled(\"Chat\", false)\n\t\t\ticon:deselect()\n\t\t\ticon.updated:Fire()\n\t\t\ticon.ignoreVisibilityStateChange = nil\n\t\tend\n\t\t-- Open chat via Slash key\n\t\ticon._fakeChatMaid:give(userInputService.InputEnded:Connect(function(inputObject, gameProcessedEvent)\n\t\t\tif gameProcessedEvent then\n\t\t\t\treturn \"Another menu has priority\"\n\t\t\telseif not(inputObject.KeyCode == Enum.KeyCode.Slash or inputObject.KeyCode == Enum.SpecialKey.ChatHotkey) then\n\t\t\t\treturn \"No relavent key pressed\"\n\t\t\telseif ChatMain.IsFocused() then\n\t\t\t\treturn \"Chat bar already open\"\n\t\t\telseif not icon.enabled then\n\t\t\t\treturn \"Icon disabled\"\n\t\t\tend\n\t\t\tChatMain:FocusChatBar(true)\n\t\t\ticon:select()\n\t\tend))\n\t\t-- ChatActive\n\t\ticon._fakeChatMaid:give(ChatMain.VisibilityStateChanged:Connect(function(visibility)\n\t\t\tif not icon.ignoreVisibilityStateChange then\n\t\t\t\tif visibility == true then\n\t\t\t\t\ticon:select()\n\t\t\t\telse\n\t\t\t\t\ticon:deselect()\n\t\t\t\tend\n\t\t\tend\n\t\tend))\n\t\t-- Keep when other icons selected\n\t\ticon.deselectWhenOtherIconSelected = false\n\t\t-- Mimic chat notifications\n\t\ticon._fakeChatMaid:give(ChatMain.MessagesChanged:connect(function()\n\t\t\tif ChatMain:GetVisibility() == true then\n\t\t\t\treturn \"ChatWindow was open\"\n\t\t\tend\n\t\t\ticon:notify(icon.selected)\n\t\tend))\n\t\t-- Mimic visibility when StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, state) is called\n\t\tcoroutine.wrap(function()\n\t\t\trunService.Heartbeat:Wait()\n\t\t\ticon._fakeChatMaid:give(ChatMain.CoreGuiEnabled:connect(function(newState)\n\t\t\t\tif icon.ignoreVisibilityStateChange then\n\t\t\t\t\treturn \"ignoreVisibilityStateChange enabled\"\n\t\t\t\tend\n\t\t\t\tlocal topbarEnabled = starterGui:GetCore(\"TopbarEnabled\")\n\t\t\t\tif topbarEnabled ~= IconController.previousTopbarEnabled then\n\t\t\t\t\treturn \"SetCore was called instead of SetCoreGuiEnabled\"\n\t\t\t\tend\n\t\t\t\tif not icon.enabled and userInputService:IsKeyDown(Enum.KeyCode.LeftShift) and userInputService:IsKeyDown(Enum.KeyCode.P) then\n\t\t\t\t\ticon:setEnabled(true)\n\t\t\t\telse\n\t\t\t\t\tsetIconEnabled(newState)\n\t\t\t\tend\n\t\t\tend))\n\t\tend)()\n\t\ticon.deselected:Connect(function()\n\t\t\tdisplayChatBar(false)\n\t\tend)\n\t\ticon.selected:Connect(function()\n\t\t\tdisplayChatBar(true)\n\t\tend)\n\t\tsetIconEnabled(starterGui:GetCoreGuiEnabled(\"Chat\"))\n\t\t--]]\n\tend\n\treturn icon\nend\n\n\n\n-- CORE UTILITY METHODS\nfunction Icon:set(settingName, value, iconState, setAdditional)\n\tlocal settingDetail = self._settingsDictionary[settingName]\n\tassert(settingDetail ~= nil, (\"setting '%s' does not exist\"):format(settingName))\n\tif type(iconState) == \"string\" then\n\t\ticonState = iconState:lower()\n\tend\n\tlocal previousValue = self:get(settingName, iconState)\n\n\tif iconState == \"hovering\" then\n\t\t-- Apply hovering state if valid\n\t\tsettingDetail.hoveringValue = value\n\t\tif setAdditional ~= \"_ignorePrevious\" then\n\t\t\tsettingDetail.additionalValues[\"previous_\"..iconState] = previousValue\n\t\tend\n\t\tif type(setAdditional) == \"string\" then\n\t\t\tsettingDetail.additionalValues[setAdditional..\"_\"..iconState] = previousValue\n\t\tend\n\t\tself:_update(settingName)\n\n\telse\n\t\t-- Update the settings value\n\t\tlocal toggleState = iconState\n\t\tlocal settingType = settingDetail.type\n\t\tif settingType == \"toggleable\" then\n\t\t\tlocal valuesToSet = {}\n\t\t\tif toggleState == \"deselected\" or toggleState == \"selected\" then\n\t\t\t\ttable.insert(valuesToSet, toggleState)\n\t\t\telse\n\t\t\t\ttable.insert(valuesToSet, \"deselected\")\n\t\t\t\ttable.insert(valuesToSet, \"selected\")\n\t\t\t\ttoggleState = nil\n\t\t\tend\n\t\t\tfor i, v in pairs(valuesToSet) do\n\t\t\t\tsettingDetail.values[v] = value\n\t\t\t\tif setAdditional ~= \"_ignorePrevious\" then\n\t\t\t\t\tsettingDetail.additionalValues[\"previous_\"..v] = previousValue\n\t\t\t\tend\n\t\t\t\tif type(setAdditional) == \"string\" then\n\t\t\t\t\tsettingDetail.additionalValues[setAdditional..\"_\"..v] = previousValue\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tsettingDetail.value = value\n\t\t\tif type(setAdditional) == \"string\" then\n\t\t\t\tif setAdditional ~= \"_ignorePrevious\" then\n\t\t\t\t\tsettingDetail.additionalValues[\"previous\"] = previousValue\n\t\t\t\tend\n\t\t\t\tsettingDetail.additionalValues[setAdditional] = previousValue\n\t\t\tend\n\t\tend\n\n\t\t-- Check previous and new are not the same\n\t\tif previousValue == value then\n\t\t\treturn self, \"Value was already set\"\n\t\tend\n\n\t\t-- Update appearances of associated instances\n\t\tlocal currentToggleState = self:getToggleState()\n\t\tif not self._updateAfterSettingAll and settingDetail.instanceNames and (currentToggleState == toggleState or toggleState == nil) then\n\t\t\tlocal ignoreTweenAction = (settingName == \"iconSize\" and previousValue and previousValue.X.Scale == 1)\n\t\t\tlocal tweenInfo = (settingDetail.tweenAction and not ignoreTweenAction and self:get(settingDetail.tweenAction)) or TweenInfo.new(0)\n\t\t\tself:_update(settingName, currentToggleState, tweenInfo)\n\t\tend\n\tend\n\n\t-- Call any methods present\n\tif settingDetail.callMethods then\n\t\tfor _, callMethod in pairs(settingDetail.callMethods) do\n\t\t\tcallMethod(self, value, iconState)\n\t\tend\n\tend\n\t\n\t-- Call any signals present\n\tif settingDetail.callSignals then\n\t\tfor _, callSignal in pairs(settingDetail.callSignals) do\n\t\t\tcallSignal:Fire()\n\t\tend\n\tend\n\treturn self\nend\n\nfunction Icon:setAdditionalValue(settingName, setAdditional, value, iconState)\n\tlocal settingDetail = self._settingsDictionary[settingName]\n\tassert(settingDetail ~= nil, (\"setting '%s' does not exist\"):format(settingName))\n\tlocal stringMatch = setAdditional..\"_\"\n\tif iconState then\n\t\tstringMatch = stringMatch..iconState\n\tend\n\tfor key, _ in pairs(settingDetail.additionalValues) do\n\t\tif string.match(key, stringMatch) then\n\t\t\tsettingDetail.additionalValues[key] = value\n\t\tend\n\tend\nend\n\nfunction Icon:get(settingName, iconState, getAdditional)\n\tlocal settingDetail = self._settingsDictionary[settingName]\n\tassert(settingDetail ~= nil, (\"setting '%s' does not exist\"):format(settingName))\n\tlocal valueToReturn, additionalValueToReturn\n\tif typeof(iconState) == \"string\" then\n\t\ticonState = iconState:lower()\n\tend\n\n\t--if ((self.hovering and settingDetail.hoveringValue) or iconState == \"hovering\") and getAdditional == nil then\n\tif (iconState == \"hovering\") and getAdditional == nil then\n\t\tvalueToReturn = settingDetail.hoveringValue\n\t\tadditionalValueToReturn = type(getAdditional) == \"string\" and settingDetail.additionalValues[getAdditional..\"_\"..iconState]\n\tend\n\n\tlocal settingType = settingDetail.type\n\tif settingType == \"toggleable\" then\n\t\tlocal toggleState = ((iconState == \"deselected\" or iconState == \"selected\") and iconState) or self:getToggleState()\n\t\tif additionalValueToReturn == nil then\n\t\t\tadditionalValueToReturn = type(getAdditional) == \"string\" and settingDetail.additionalValues[getAdditional..\"_\"..toggleState]\n\t\tend\n\t\tif valueToReturn == nil then\n\t\t\tvalueToReturn = settingDetail.values[toggleState]\n\t\tend\n\t\n\telse\n\t\tif additionalValueToReturn == nil then\n\t\t\tadditionalValueToReturn = type(getAdditional) == \"string\" and settingDetail.additionalValues[getAdditional]\n\t\tend\n\t\tif valueToReturn == nil then\n\t\t\tvalueToReturn = settingDetail.value\n\t\tend\n\tend\n\n\treturn valueToReturn, additionalValueToReturn\nend\n\nfunction Icon:getHovering(settingName)\n\tlocal settingDetail = self._settingsDictionary[settingName]\n\tassert(settingDetail ~= nil, (\"setting '%s' does not exist\"):format(settingName))\n\treturn settingDetail.hoveringValue\nend\n\nfunction Icon:getToggleState(isSelected)\n\tisSelected = isSelected or self.isSelected\n\treturn (isSelected and \"selected\") or \"deselected\"\nend\n\nfunction Icon:getIconState()\n\tif self.hovering then\n\t\treturn \"hovering\"\n\telse\n\t\treturn self:getToggleState()\n\tend\nend\n\nfunction Icon:_update(settingName, toggleState, customTweenInfo)\n\tlocal settingDetail = self._settingsDictionary[settingName]\n\tassert(settingDetail ~= nil, (\"setting '%s' does not exist\"):format(settingName))\n\ttoggleState = toggleState or self:getToggleState()\n\tlocal value = settingDetail.value or (settingDetail.values and settingDetail.values[toggleState])\n\tif self.hovering and settingDetail.hoveringValue then\n\t\tvalue = settingDetail.hoveringValue\n\tend\n\tif value == nil then return end\n\tlocal tweenInfo = customTweenInfo or (settingDetail.tweenAction and settingDetail.tweenAction ~= \"\" and self:get(settingDetail.tweenAction)) or self:get(\"toggleTransitionInfo\") or TweenInfo.new(0.15)\n\tlocal propertyName = settingDetail.propertyName\n\tlocal invalidPropertiesTypes = {\n\t\t[\"string\"] = true,\n\t\t[\"NumberSequence\"] = true,\n\t\t[\"Text\"] = true,\n\t\t[\"EnumItem\"] = true,\n\t\t[\"ColorSequence\"] = true,\n\t}\n\tlocal uniqueSetting = self._uniqueSettingsDictionary[settingName]\n\tlocal newValue = value\n\tif settingDetail.useForcedGroupValue then\n\t\tnewValue = settingDetail.forcedGroupValue\n\tend\n\tif settingDetail.instanceNames then\n\t\tfor _, instanceName in pairs(settingDetail.instanceNames) do\n\t\t\tlocal instance = self.instances[instanceName]\n\t\t\tlocal propertyType = typeof(instance[propertyName])\n\t\t\tlocal cannotTweenProperty = invalidPropertiesTypes[propertyType] or typeof(instance) == \"table\"\n\t\t\tif uniqueSetting then\n\t\t\t\tuniqueSetting(settingName, instance, propertyName, newValue)\n\t\t\telseif cannotTweenProperty then\n\t\t\t\tinstance[propertyName] = value\n\t\t\telse\n\t\t\t\ttweenService:Create(instance, tweenInfo, {[propertyName] = newValue}):Play()\n\t\t\tend\n\t\t\t--\n\t\t\tif settingName == \"iconSize\" and instance[propertyName] ~= newValue then\n\t\t\t\tself.updated:Fire()\n\t\t\tend\n\t\t\t--\n\t\tend\n\tend\nend\n\nfunction Icon:_updateAll(iconState, customTweenInfo)\n\tfor settingName, settingDetail in pairs(self._settingsDictionary) do\n\t\tif settingDetail.instanceNames then\n\t\t\tself:_update(settingName, iconState, customTweenInfo)\n\t\tend\n\tend\nend\n\nfunction Icon:_updateHovering(customTweenInfo)\n\tfor settingName, settingDetail in pairs(self._settingsDictionary) do\n\t\tif settingDetail.instanceNames and settingDetail.hoveringValue ~= nil then\n\t\t\tself:_update(settingName, nil, customTweenInfo)\n\t\tend\n\tend\nend\n\nfunction Icon:_updateStateOverlay(transparency, color)\n\tlocal stateOverlay = self.instances.iconOverlay\n\tstateOverlay.BackgroundTransparency = transparency or 1\n\tstateOverlay.BackgroundColor3 = color or Color3.new(1, 1, 1)\nend\n\nfunction Icon:setTheme(theme, updateAfterSettingAll)\n\tself._updateAfterSettingAll = updateAfterSettingAll\n\tfor settingsType, settingsDetails in pairs(theme) do\n\t\tif settingsType == \"toggleable\" then\n\t\t\tfor settingName, settingValue in pairs(settingsDetails.deselected) do\n\t\t\t\tif not self.lockedSettings[settingName] then\n\t\t\t\t\tself:set(settingName, settingValue, \"both\")\n\t\t\t\tend\n\t\t\tend\n\t\t\tfor settingName, settingValue in pairs(settingsDetails.selected) do\n\t\t\t\tif not self.lockedSettings[settingName] then\n\t\t\t\t\tself:set(settingName, settingValue, \"selected\")\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tfor settingName, settingValue in pairs(settingsDetails) do\n\t\t\t\tif not self.lockedSettings[settingName] then\n\t\t\t\t\tlocal settingDetail = self._settingsDictionary[settingName]\n\t\t\t\t\tif settingsType == \"action\" and settingDetail == nil then\n\t\t\t\t\t\tsettingDetail = {}\n\t\t\t\t\t\tself._settingsDictionary[settingName] = {}\n\t\t\t\t\tend\n\t\t\t\t\tself:set(settingName, settingValue)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tself._updateAfterSettingAll = nil\n\tif updateAfterSettingAll then\n\t\tself:_updateAll()\n\tend\n\treturn self\nend\n\nfunction Icon:getInstance(instanceName)\n\treturn self.instances[instanceName]\nend\n\nfunction Icon:setInstance(instanceName, instance)\n\tlocal originalInstance = self.instances[instanceName]\n\tself.instances[instanceName] = instance\n\tif originalInstance then\n\t\toriginalInstance:Destroy()\n\tend\n\treturn self\nend\n\nfunction Icon:getSettingDetail(targetSettingName)\n\tfor _, settingsDetails in pairs(self._settings) do\n\t\tfor settingName, settingDetail in pairs(settingsDetails) do\n\t\t\tif settingName == targetSettingName then\n\t\t\t\treturn settingDetail\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\n\nfunction Icon:modifySetting(settingName, dictionary)\n\tlocal settingDetail = self:getSettingDetail(settingName)\n\tfor key, value in pairs(dictionary) do\n\t\tsettingDetail[key] = value\n\tend\n\treturn self\nend\n\nfunction Icon:convertLabelToNumberSpinner(numberSpinner)\n\t-- This updates the number spinners appearance\n\tself:set(\"iconLabelSize\", UDim2.new(1,0,1,0))\n\tnumberSpinner.Parent = self:getInstance(\"iconButton\")\n\n\t-- This creates a fake iconLabel which updates the property of all descendant spinner TextLabels when indexed\n\tlocal textLabel = {}\n\tsetmetatable(textLabel, {__newindex = function(_, index, value)\n\t\tfor _, label in pairs(numberSpinner.Frame:GetDescendants()) do\n\t\t\tif label:IsA(\"TextLabel\") then\n\t\t\t\tlabel[index] = value\n\t\t\tend\n\t\tend\n\tend})\n\n\t-- This overrides existing instances and settings so that they update the spinners properties (instead of the old textlabel)\n\tlocal iconButton = self:getInstance(\"iconButton\")\n\ticonButton.ZIndex = 0\n\tself:setInstance(\"iconLabel\", textLabel)\n\tself:modifySetting(\"iconText\", {instanceNames = {}}) -- We do this to prevent text being modified within the metatable above\n\tself:setInstance(\"iconLabelSpinner\", numberSpinner.Frame)\n\tlocal settingsToConvert = {\"iconLabelVisible\", \"iconLabelAnchorPoint\", \"iconLabelPosition\", \"iconLabelSize\"}\n\tfor _, settingName in pairs(settingsToConvert) do\n\t\tself:modifySetting(settingName, {instanceNames = {\"iconLabelSpinner\"}})\n\tend\n\n\t-- This applies all the values we just updated\n\tself:_updateAll()\n\treturn self\nend\n\nfunction Icon:setEnabled(bool)\n\tself.enabled = bool\n\tself.instances.iconContainer.Visible = bool\n\tself.updated:Fire()\n\treturn self\nend\n\nfunction Icon:setName(string)\n\tself.name = string\n\tself.instances.iconContainer.Name = string\n\treturn self\nend\n\nfunction Icon:setProperty(propertyName, value)\n\tself[propertyName] = value\n\treturn self\nend\n\nfunction Icon:_playClickSound()\n\tlocal clickSound = self.instances.clickSound\n\tif clickSound.SoundId ~= nil and #clickSound.SoundId > 0 and clickSound.Volume > 0 then\n\t\tlocal clickSoundCopy = clickSound:Clone()\n\t\tclickSoundCopy.Parent = clickSound.Parent\n\t\tclickSoundCopy:Play()\n\t\tdebris:AddItem(clickSoundCopy, clickSound.TimeLength)\n\tend\nend\n\nfunction Icon:select(byIcon)\n\tif self.locked then return self end\n\tself.isSelected = true\n\tself:_setToggleItemsVisible(true, byIcon)\n\tself:_updateNotice()\n\tself:_updateAll()\n\tself:_playClickSound()\n\tif #self.dropdownIcons > 0 or #self.menuIcons > 0 then\n\t\tIconController:_updateSelectionGroup()\n\tend\n    self.selected:Fire()\n    self.toggled:Fire(self.isSelected)\n\treturn self\nend\n\nfunction Icon:deselect(byIcon)\n\tif self.locked then return self end\n\tself.isSelected = false\n\tself:_setToggleItemsVisible(false, byIcon)\n\tself:_updateNotice()\n\tself:_updateAll()\n\tself:_playClickSound()\n\tif #self.dropdownIcons > 0 or #self.menuIcons > 0 then\n\t\tIconController:_updateSelectionGroup()\n\tend\n    self.deselected:Fire()\n    self.toggled:Fire(self.isSelected)\n\treturn self\nend\n\nfunction Icon:notify(clearNoticeEvent, noticeId)\n\tcoroutine.wrap(function()\n\t\tif not clearNoticeEvent then\n\t\t\tclearNoticeEvent = self.deselected\n\t\tend\n\t\tif self._parentIcon then\n\t\t\tself._parentIcon:notify(clearNoticeEvent)\n\t\tend\n\t\t\n\t\tlocal notifComplete = Signal.new()\n\t\tlocal endEvent = self._endNotices:Connect(function()\n\t\t\tnotifComplete:Fire()\n\t\tend)\n\t\tlocal customEvent = clearNoticeEvent:Connect(function()\n\t\t\tnotifComplete:Fire()\n\t\tend)\n\t\t\n\t\tnoticeId = noticeId or httpService:GenerateGUID(true)\n\t\tself.notices[noticeId] = {\n\t\t\tcompleteSignal = notifComplete,\n\t\t\tclearNoticeEvent = clearNoticeEvent,\n\t\t}\n\t\tself.totalNotices += 1\n\t\tself:_updateNotice()\n\n\t\tself.notified:Fire(noticeId)\n\t\tnotifComplete:Wait()\n\t\t\n\t\tendEvent:Disconnect()\n\t\tcustomEvent:Disconnect()\n\t\tnotifComplete:Disconnect()\n\t\t\n\t\tself.totalNotices -= 1\n\t\tself.notices[noticeId] = nil\n\t\tself:_updateNotice()\n\tend)()\n\treturn self\nend\n\nfunction Icon:_updateNotice()\n\tlocal enabled = true\n\tif self.totalNotices < 1 then\n\t\tenabled = false\n\tend\n\t-- Deselect\n\tif not self.isSelected then\n\t\tif (#self.dropdownIcons > 0 or #self.menuIcons > 0) and self.totalNotices > 0 then\n\t\t\tenabled = true\n\t\tend\n\tend\n\t-- Select\n\tif self.isSelected then\n\t\tif #self.dropdownIcons > 0 or #self.menuIcons > 0 then\n\t\t\tenabled = false\n\t\tend\n\tend\n\tlocal value = (enabled and 0) or 1\n\tself:set(\"noticeImageTransparency\", value)\n\tself:set(\"noticeTextTransparency\", value)\n\tself.instances.noticeLabel.Text = (self.totalNotices < 100 and self.totalNotices) or \"99+\"\nend\n\nfunction Icon:clearNotices()\n\tself._endNotices:Fire()\n\treturn self\nend\n\nfunction Icon:disableStateOverlay(bool)\n\tif bool == nil then\n\t\tbool = true\n\tend\n\tlocal stateOverlay = self.instances.iconOverlay\n\tstateOverlay.Visible = not bool\n\treturn self\nend\n\n\n\n-- TOGGLEABLE METHODS\nfunction Icon:setLabel(text, iconState)\n\ttext = text or \"\"\n\tself:set(\"iconText\", text, iconState)\n\treturn self\nend\n\nfunction Icon:setCornerRadius(scale, offset, iconState)\n\tlocal oldCornerRadius = self.instances.iconCorner.CornerRadius\n\tlocal newCornerRadius = UDim.new(scale or oldCornerRadius.Scale, offset or oldCornerRadius.Offset)\n\tself:set(\"iconCornerRadius\", newCornerRadius, iconState)\n\treturn self\nend\n\nfunction Icon:setImage(imageId, iconState)\n\tlocal textureId = (tonumber(imageId) and \"http://www.roblox.com/asset/?id=\"..imageId) or imageId or \"\"\n\treturn self:set(\"iconImage\", textureId, iconState)\nend\n\nfunction Icon:setOrder(order, iconState)\n\tlocal newOrder = tonumber(order) or 1\n\treturn self:set(\"order\", newOrder, iconState)\nend\n\nfunction Icon:setLeft(iconState)\n\treturn self:set(\"alignment\", \"left\", iconState)\nend\n\nfunction Icon:setMid(iconState)\n\treturn self:set(\"alignment\", \"mid\", iconState)\nend\n\nfunction Icon:setRight(iconState)\n\tif not self.internalIcon then\n\t\tIconController.setupHealthbar()\n\tend\n\treturn self:set(\"alignment\", \"right\", iconState)\nend\n\nfunction Icon:setImageYScale(YScale, iconState)\n\tlocal newYScale = tonumber(YScale) or 0.63\n\treturn self:set(\"iconImageYScale\", newYScale, iconState)\nend\n\nfunction Icon:setImageRatio(ratio, iconState)\n\tlocal newRatio = tonumber(ratio) or 1\n\treturn self:set(\"iconImageRatio\", newRatio, iconState)\nend\n\nfunction Icon:setLabelYScale(YScale, iconState)\n\tlocal newYScale = tonumber(YScale) or 0.45\n\treturn self:set(\"iconLabelYScale\", newYScale, iconState)\nend\n\t\nfunction Icon:setBaseZIndex(ZIndex, iconState)\n\tlocal newBaseZIndex = tonumber(ZIndex) or 1\n\treturn self:set(\"baseZIndex\", newBaseZIndex, iconState)\nend\n\nfunction Icon:_updateBaseZIndex(baseValue)\n\tlocal container = self.instances.iconContainer\n\tlocal newBaseValue = tonumber(baseValue) or container.ZIndex\n\tlocal difference = newBaseValue - container.ZIndex\n\tif difference == 0 then return \"The baseValue is the same\" end\n\tfor _, object in pairs(self.instances) do\n\t\tobject.ZIndex = object.ZIndex + difference\n\tend\n\treturn true\nend\n\nfunction Icon:setSize(XOffset, YOffset, iconState)\n\tlocal newXOffset = tonumber(XOffset) or 32\n\tlocal newYOffset = tonumber(YOffset) or newXOffset\n\tself:set(\"forcedIconSize\", UDim2.new(0, newXOffset, 0, newYOffset), iconState)\n\tself:set(\"iconSize\", UDim2.new(0, newXOffset, 0, newYOffset), iconState)\n\treturn self\nend\n\nfunction Icon:_updateIconSize(_, iconState)\n\tif self._destroyed then return end\n\t-- This is responsible for handling the appearance and size of the icons label and image, in additon to its own size\n\tlocal X_MARGIN = 12\n\tlocal X_GAP = 8\n\n\tlocal values = {\n\t\ticonImage = self:get(\"iconImage\", iconState) or \"_NIL\",\n\t\ticonText = self:get(\"iconText\", iconState) or \"_NIL\",\n\t\ticonFont = self:get(\"iconFont\", iconState) or \"_NIL\",\n\t\ticonSize = self:get(\"iconSize\", iconState) or \"_NIL\",\n\t\tforcedIconSize = self:get(\"forcedIconSize\", iconState) or \"_NIL\",\n\t\ticonImageYScale = self:get(\"iconImageYScale\", iconState) or \"_NIL\",\n\t\ticonImageRatio = self:get(\"iconImageRatio\", iconState) or \"_NIL\",\n\t\ticonLabelYScale = self:get(\"iconLabelYScale\", iconState) or \"_NIL\",\n\t}\n\tfor k,v in pairs(values) do\n\t\tif v == \"_NIL\" then\n\t\t\treturn\n\t\tend\n\tend\n\n\tlocal iconContainer = self.instances.iconContainer\n\tif not iconContainer.Parent then return end\n\n\t-- We calculate the cells dimensions as apposed to reading because there's a possibility the cells dimensions were changed at the exact time and have not yet updated\n\t-- this essentially saves us from waiting a heartbeat which causes additonal complications\n\tlocal cellSizeXOffset = values.iconSize.X.Offset\n\tlocal cellSizeXScale = values.iconSize.X.Scale\n\tlocal cellWidth = cellSizeXOffset + (cellSizeXScale * iconContainer.Parent.AbsoluteSize.X)\n\tlocal minCellWidth = values.forcedIconSize.X.Offset--cellWidth\n\tlocal maxCellWidth = (cellSizeXScale > 0 and cellWidth) or 9999\n\tlocal cellSizeYOffset = values.iconSize.Y.Offset\n\tlocal cellSizeYScale = values.iconSize.Y.Scale\n\tlocal cellHeight = cellSizeYOffset + (cellSizeYScale * iconContainer.Parent.AbsoluteSize.Y)\n\tlocal labelHeight = cellHeight * values.iconLabelYScale\n\tlocal labelWidth = textService:GetTextSize(values.iconText, labelHeight, values.iconFont, Vector2.new(10000, labelHeight)).X\n\tlocal imageWidth = cellHeight * values.iconImageYScale * values.iconImageRatio\n\t\n\tlocal usingImage = values.iconImage ~= \"\"\n\tlocal usingText = values.iconText ~= \"\"\n\tlocal notifPosYScale = 0.5\n\tlocal desiredCellWidth\n\tlocal preventClippingOffset = labelHeight/2\n\t\n\tif usingImage and not usingText then\n\t\tnotifPosYScale = 0.45\n\t\tself:set(\"iconImageVisible\", true, iconState)\n\t\tself:set(\"iconImageAnchorPoint\", Vector2.new(0.5, 0.5), iconState)\n\t\tself:set(\"iconImagePosition\", UDim2.new(0.5, 0, 0.5, 0), iconState)\n\t\tself:set(\"iconImageSize\", UDim2.new(values.iconImageYScale*values.iconImageRatio, 0, values.iconImageYScale, 0), iconState)\n\t\tself:set(\"iconLabelVisible\", false, iconState)\n\n\telseif not usingImage and usingText then\n\t\tdesiredCellWidth = labelWidth+(X_MARGIN*2)\n\t\tself:set(\"iconLabelVisible\", true, iconState)\n\t\tself:set(\"iconLabelAnchorPoint\", Vector2.new(0, 0.5), iconState)\n\t\tself:set(\"iconLabelPosition\", UDim2.new(0, X_MARGIN, 0.5, 0), iconState)\n\t\tself:set(\"iconLabelSize\", UDim2.new(1, -X_MARGIN*2, values.iconLabelYScale, preventClippingOffset), iconState)\n\t\tself:set(\"iconLabelTextXAlignment\", Enum.TextXAlignment.Center, iconState)\n\t\tself:set(\"iconImageVisible\", false, iconState)\n\n\telseif usingImage and usingText then\n\t\tlocal labelGap = X_MARGIN + imageWidth + X_GAP\n\t\tdesiredCellWidth = labelGap + labelWidth + X_MARGIN\n\t\tself:set(\"iconImageVisible\", true, iconState)\n\t\tself:set(\"iconImageAnchorPoint\", Vector2.new(0, 0.5), iconState)\n\t\tself:set(\"iconImagePosition\", UDim2.new(0, X_MARGIN, 0.5, 0), iconState)\n\t\tself:set(\"iconImageSize\", UDim2.new(0, imageWidth, values.iconImageYScale, 0), iconState)\n\t\t----\n\t\tself:set(\"iconLabelVisible\", true, iconState)\n\t\tself:set(\"iconLabelAnchorPoint\", Vector2.new(0, 0.5), iconState)\n\t\tself:set(\"iconLabelPosition\", UDim2.new(0, labelGap, 0.5, 0), iconState)\n\t\tself:set(\"iconLabelSize\", UDim2.new(1, -labelGap-X_MARGIN, values.iconLabelYScale, preventClippingOffset), iconState)\n\t\tself:set(\"iconLabelTextXAlignment\", Enum.TextXAlignment.Left, iconState)\n\tend\n\tif desiredCellWidth then\n\t\tif not self._updatingIconSize then\n\t\t\tself._updatingIconSize = true\n\t\t\tlocal widthScale = (cellSizeXScale > 0 and cellSizeXScale) or 0\n\t\t\tlocal widthOffset = (cellSizeXScale > 0 and 0) or math.clamp(desiredCellWidth, minCellWidth, maxCellWidth)\n\t\t\tself:set(\"iconSize\", UDim2.new(widthScale, widthOffset, values.iconSize.Y.Scale, values.iconSize.Y.Offset), iconState, \"_ignorePrevious\")\n\n\t\t\t-- This ensures that if an icon is within a dropdown or menu, its container adapts accordingly with this new iconSize value\n\t\t\tlocal parentIcon = self._parentIcon\n\t\t\tif parentIcon then\n\t\t\t\tlocal originalIconSize = UDim2.new(0, desiredCellWidth, 0, values.iconSize.Y.Offset)\n\t\t\t\tif #parentIcon.dropdownIcons > 0 then\n\t\t\t\t\tself:setAdditionalValue(\"iconSize\", \"beforeDropdown\", originalIconSize, iconState)\n\t\t\t\t\tparentIcon:_updateDropdown()\n\t\t\t\tend\n\t\t\t\tif #parentIcon.menuIcons > 0 then\n\t\t\t\t\tself:setAdditionalValue(\"iconSize\", \"beforeMenu\", originalIconSize, iconState)\n\t\t\t\t\tparentIcon:_updateMenu()\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tself._updatingIconSize = false\n\t\tend\n\tend\n\tself:set(\"iconLabelTextSize\", labelHeight, iconState)\n\tself:set(\"noticeFramePosition\", UDim2.new(notifPosYScale, 0, 0, -2), iconState)\n\n\tself._updatingIconSize = false\nend\n\n\n\n-- FEATURE METHODS\nfunction Icon:bindEvent(iconEventName, eventFunction)\n\tlocal event = self[iconEventName]\n\tassert(event and typeof(event) == \"table\" and event.Connect, \"argument[1] must be a valid topbarplus icon event name!\")\n\tassert(typeof(eventFunction) == \"function\", \"argument[2] must be a function!\")\n\tself._bindedEvents[iconEventName] = event:Connect(function(...)\n\t\teventFunction(self, ...)\n\tend)\n\treturn self\nend\n\nfunction Icon:unbindEvent(iconEventName)\n\tlocal eventConnection = self._bindedEvents[iconEventName]\n\tif eventConnection then\n\t\teventConnection:Disconnect()\n\t\tself._bindedEvents[iconEventName] = nil\n\tend\n\treturn self\nend\n\nfunction Icon:bindToggleKey(keyCodeEnum)\n\tassert(typeof(keyCodeEnum) == \"EnumItem\", \"argument[1] must be a KeyCode EnumItem!\")\n\tself._bindedToggleKeys[keyCodeEnum] = true\n\treturn self\nend\n\nfunction Icon:unbindToggleKey(keyCodeEnum)\n\tassert(typeof(keyCodeEnum) == \"EnumItem\", \"argument[1] must be a KeyCode EnumItem!\")\n\tself._bindedToggleKeys[keyCodeEnum] = nil\n\treturn self\nend\n\nfunction Icon:lock()\n\tself.locked = true\n\treturn self\nend\n\nfunction Icon:unlock()\n\tself.locked = false\n\treturn self\nend\n\nfunction Icon:setTopPadding(offset, scale)\n\tlocal newOffset = offset or 4\n\tlocal newScale = scale or 0\n\tself.topPadding = UDim.new(newScale, newOffset)\n\tself.updated:Fire()\n\treturn self\nend\n\nfunction Icon:bindToggleItem(guiObjectOrLayerCollector)\n\tif not guiObjectOrLayerCollector:IsA(\"GuiObject\") and not guiObjectOrLayerCollector:IsA(\"LayerCollector\") then\n\t\terror(\"Toggle item must be a GuiObject or LayerCollector!\")\n\tend\n\tself.toggleItems[guiObjectOrLayerCollector] = true\n\treturn self\nend\n\nfunction Icon:unbindToggleItem(guiObjectOrLayerCollector)\n\tself.toggleItems[guiObjectOrLayerCollector] = nil\n\treturn self\nend\n\nfunction Icon:_setToggleItemsVisible(bool, byIcon)\n\tfor toggleItem, _ in pairs(self.toggleItems) do\n\t\tif not byIcon or byIcon.toggleItems[toggleItem] == nil then\n\t\t\tlocal property = \"Visible\"\n\t\t\tif toggleItem:IsA(\"LayerCollector\") then\n\t\t\t\tproperty = \"Enabled\"\n\t\t\tend\n\t\t\ttoggleItem[property] = bool\n\t\tend\n\tend\nend\n\nfunction Icon:give(userdata)\n\tlocal valueToGive = userdata\n\tif typeof(userdata) == \"function\" then\n\t\tlocal returnValue = userdata(self)\n\t\tif typeof(userdata) ~= \"function\" then\n\t\t\tvalueToGive = returnValue\n\t\telse\n\t\t\tvalueToGive = nil\n\t\tend\n\tend\n\tif valueToGive ~= nil then\n\t\tself._maid:give(valueToGive)\n\tend\n\treturn self\nend\n\n-- Tips\nDEFAULT_FORCED_GROUP_VALUES[\"tip\"] = 1\n\nfunction Icon:setTip(text)\n\tassert(typeof(text) == \"string\" or text == nil, \"Expected string, got \"..typeof(text))\n\tlocal realText = text or \"\"\n\tlocal isVisible = realText ~= \"\"\n\tlocal textSize = textService:GetTextSize(realText, 12, Enum.Font.GothamSemibold, Vector2.new(1000, 20-6))\n\tself.instances.tipLabel.Text = realText\n\tself.instances.tipFrame.Size = (isVisible and UDim2.new(0, textSize.X+6, 0, 20)) or UDim2.new(0, 0, 0, 0)\n\tself.instances.tipFrame.Parent = (isVisible and activeItems) or self.instances.iconContainer\n\tself._maid.tipFrame = self.instances.tipFrame\n\tself.tipText = text\n\t\n\tlocal tipMaid = Maid.new()\n\tself._maid.tipMaid = tipMaid\n\tif isVisible then\n\t\ttipMaid:give(self.hoverStarted:Connect(function()\n\t\t\tif not self.isSelected then\n\t\t\t\tself:displayTip(true)\n\t\t\tend\n\t\tend))\n\t\ttipMaid:give(self.hoverEnded:Connect(function()\n\t\t\tself:displayTip(false)\n\t\tend))\n\t\ttipMaid:give(self.selected:Connect(function()\n\t\t\tif self.hovering then\n\t\t\t\tself:displayTip(false)\n\t\t\tend\n\t\tend))\n\tend\n\tself:displayTip(self.hovering and isVisible)\n\treturn self\nend\n\nfunction Icon:displayTip(bool)\n\tif userInputService.TouchEnabled and not self._draggingFinger then return end\n\n\t-- Determine caption visibility\n\tlocal isVisible = self.tipVisible or false\n\tif typeof(bool) == \"boolean\" then\n\t\tisVisible = bool\n\tend\n\tself.tipVisible = isVisible\n\n\t-- Have tip position track mouse or finger\n\tlocal tipFrame = self.instances.tipFrame\n\tif isVisible then\n\t\t-- When the user moves their cursor/finger, update tip to match the position\n\t\tlocal function updateTipPositon(x, y)\n\t\t\tlocal newX = x\n\t\t\tlocal newY = y\n\t\t\tlocal camera = workspace.CurrentCamera\n\t\t\tlocal viewportSize = camera and camera.ViewportSize\n\t\t\tif userInputService.TouchEnabled then\n\t\t\t\t--tipFrame.AnchorPoint = Vector2.new(0.5, 0.5)\n\t\t\t\tlocal desiredX = newX - tipFrame.Size.X.Offset/2\n\t\t\t\tlocal minX = 0\n\t\t\t\tlocal maxX = viewportSize.X - tipFrame.Size.X.Offset\n\t\t\t\tlocal desiredY = newY + THUMB_OFFSET + 60\n\t\t\t\tlocal minY = tipFrame.AbsoluteSize.Y + THUMB_OFFSET + 64 + 3\n\t\t\t\tlocal maxY = viewportSize.Y - tipFrame.Size.Y.Offset\n\t\t\t\tnewX = math.clamp(desiredX, minX, maxX)\n\t\t\t\tnewY = math.clamp(desiredY, minY, maxY)\n\t\t\telseif IconController.controllerModeEnabled then\n\t\t\t\tlocal indicator = TopbarPlusGui.Indicator\n\t\t\t\tlocal newPos = indicator.AbsolutePosition\n\t\t\t\tnewX = newPos.X - tipFrame.Size.X.Offset/2 + indicator.AbsoluteSize.X/2\n\t\t\t\tnewY = newPos.Y + 90\n\t\t\telse\n\t\t\t\tlocal desiredX = newX\n\t\t\t\tlocal minX = 0\n\t\t\t\tlocal maxX = viewportSize.X - tipFrame.Size.X.Offset - 48\n\t\t\t\tlocal desiredY = newY\n\t\t\t\tlocal minY = tipFrame.Size.Y.Offset+3\n\t\t\t\tlocal maxY = viewportSize.Y\n\t\t\t\tnewX = math.clamp(desiredX, minX, maxX)\n\t\t\t\tnewY = math.clamp(desiredY, minY, maxY)\n\t\t\tend\n\t\t\t--local difX = tipFrame.AbsolutePosition.X - tipFrame.Position.X.Offset\n\t\t\t--local difY = tipFrame.AbsolutePosition.Y - tipFrame.Position.Y.Offset\n\t\t\t--local globalX = newX - difX\n\t\t\t--local globalY = newY - difY\n\t\t\t--tipFrame.Position = UDim2.new(0, globalX, 0, globalY-55)\n\t\t\ttipFrame.Position = UDim2.new(0, newX, 0, newY-20)\n\t\tend\n\t\tlocal cursorLocation = userInputService:GetMouseLocation()\n\t\tif cursorLocation then\n\t\t\tupdateTipPositon(cursorLocation.X, cursorLocation.Y)\n\t\tend\n\t\tself._hoveringMaid:give(self.instances.iconButton.MouseMoved:Connect(updateTipPositon))\n\tend\n\n\t-- Change transparency of relavent tip instances\n\tfor _, settingName in pairs(self._groupSettings.tip) do\n\t\tlocal settingDetail = self._settingsDictionary[settingName]\n\t\tsettingDetail.useForcedGroupValue = not isVisible\n\t\tself:_update(settingName)\n\tend\nend\n\n-- Captions\nDEFAULT_FORCED_GROUP_VALUES[\"caption\"] = 1\n\nfunction Icon:setCaption(text)\n\tassert(typeof(text) == \"string\" or text == nil, \"Expected string, got \"..typeof(text))\n\tlocal realText = text or \"\"\n\tlocal isVisible = realText ~= \"\"\n\tself.captionText = text\n\tself.instances.captionLabel.Text = realText\n\tself.instances.captionContainer.Parent = (isVisible and activeItems) or self.instances.iconContainer\n\tself._maid.captionContainer = self.instances.captionContainer\n\tself:_updateIconSize(nil, self:getIconState())\n\tlocal captionMaid = Maid.new()\n\tself._maid.captionMaid = captionMaid\n\tif isVisible then\n\t\tcaptionMaid:give(self.hoverStarted:Connect(function()\n\t\t\tif not self.isSelected then\n\t\t\t\tself:displayCaption(true)\n\t\t\tend\n\t\tend))\n\t\tcaptionMaid:give(self.hoverEnded:Connect(function()\n\t\t\tself:displayCaption(false)\n\t\tend))\n\t\tcaptionMaid:give(self.selected:Connect(function()\n\t\t\tif self.hovering then\n\t\t\t\tself:displayCaption(false)\n\t\t\tend\n\t\tend))\n\t\tlocal iconContainer = self.instances.iconContainer\n\t\tcaptionMaid:give(iconContainer:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\t\tif self.hovering then\n\t\t\t\tself:displayCaption()\n\t\t\tend\n\t\tend))\n\t\tcaptionMaid:give(iconContainer:GetPropertyChangedSignal(\"AbsolutePosition\"):Connect(function()\n\t\t\tif self.hovering then\n\t\t\t\tself:displayCaption()\n\t\t\tend\n\t\tend))\n\tend\n\n\t-- This adapts the caption size\n\tlocal CAPTION_X_MARGIN = 6\n\tlocal CAPTION_CONTAINER_Y_SIZE_SCALE = 0.8\n\tlocal CAPTION_LABEL_Y_SCALE = 0.58\n\tlocal iconSize = self:get(\"iconSize\")\n\tlocal labelFont = self:get(\"captionFont\")\n\tif iconSize and labelFont then\n\t\tlocal cellSizeYOffset = iconSize.Y.Offset\n\t\tlocal cellSizeYScale = iconSize.Y.Scale\n\t\tlocal iconContainer = self.instances.iconContainer\n\t\tlocal captionContainer = self.instances.captionContainer\n\t\tif isVisible then\n\t\t\tlocal cellHeight = cellSizeYOffset + (cellSizeYScale * iconContainer.Parent.AbsoluteSize.Y)\n\t\t\tlocal captionLabel = self.instances.captionLabel\n\t\t\tlocal captionContainerHeight = cellHeight * CAPTION_CONTAINER_Y_SIZE_SCALE\n\t\t\tlocal captionLabelHeight = captionContainerHeight * CAPTION_LABEL_Y_SCALE\n\t\t\tlocal textWidth = textService:GetTextSize(self.captionText, captionLabelHeight, labelFont, Vector2.new(10000, captionLabelHeight)).X\n\t\t\tcaptionLabel.TextSize = captionLabelHeight\n\t\t\tcaptionLabel.Size = UDim2.new(0, textWidth, CAPTION_LABEL_Y_SCALE, 0)\n\t\t\tcaptionContainer.Size = UDim2.new(0, textWidth + CAPTION_X_MARGIN*2, 0, cellHeight*CAPTION_CONTAINER_Y_SIZE_SCALE)\n\t\telse\n\t\t\tcaptionContainer.Size = UDim2.new(0, 0, 0, 0)\n\t\tend\n\tend\n\n\tself:displayCaption(self.hovering and isVisible)\n\treturn self\nend\n\nfunction Icon:displayCaption(bool)\n\tif userInputService.TouchEnabled and not self._draggingFinger then return end\n\tlocal yOffset = 8\n\t\n\t-- Determine caption position\n\tif self._draggingFinger then\n\t\tyOffset = yOffset + THUMB_OFFSET\n\tend\n\tlocal iconContainer = self.instances.iconContainer\n\tlocal captionContainer = self.instances.captionContainer\n\tlocal newPos = UDim2.new(0, iconContainer.AbsolutePosition.X+iconContainer.AbsoluteSize.X/2-captionContainer.AbsoluteSize.X/2, 0, iconContainer.AbsolutePosition.Y+(iconContainer.AbsoluteSize.Y*2)+yOffset)\n\tcaptionContainer.Position = newPos\n\n\t-- Determine caption visibility\n\tlocal isVisible = self.captionVisible or false\n\tif typeof(bool) == \"boolean\" then\n\t\tisVisible = bool\n\tend\n\tself.captionVisible = isVisible\n\n\t-- Change transparency of relavent caption instances\n\tlocal captionFadeInfo = self:get(\"captionFadeInfo\")\n\tfor _, settingName in pairs(self._groupSettings.caption) do\n\t\tlocal settingDetail = self._settingsDictionary[settingName]\n\t\tsettingDetail.useForcedGroupValue = not isVisible\n\t\tself:_update(settingName)\n\tend\nend\n\n-- Join or leave a special feature such as a Dropdown or Menu\nfunction Icon:join(parentIcon, featureName, dontUpdate)\n\tif self._parentIcon then\n\t\tself:leave()\n\tend\n\tlocal newFeatureName = (featureName and featureName:lower()) or \"dropdown\"\n\tlocal beforeName = \"before\"..featureName:sub(1,1):upper()..featureName:sub(2)\n\tlocal parentFrame = parentIcon.instances[featureName..\"Frame\"]\n\tself.presentOnTopbar = false\n\tself.joinedFeatureName = featureName\n\tself._parentIcon = parentIcon\n\tself.instances.iconContainer.Parent = parentFrame\n\tfor noticeId, noticeDetail in pairs(self.notices) do\n\t\tparentIcon:notify(noticeDetail.clearNoticeEvent, noticeId)\n\t\t--parentIcon:notify(noticeDetail.completeSignal, noticeId)\n\tend\n\t\n\tif featureName == \"dropdown\" then\n\t\tlocal squareCorners = parentIcon:get(\"dropdownSquareCorners\")\n\t\tself:set(\"iconSize\", UDim2.new(1, 0, 0, self:get(\"iconSize\", \"deselected\").Y.Offset), \"deselected\", beforeName)\n\t\tself:set(\"iconSize\", UDim2.new(1, 0, 0, self:get(\"iconSize\", \"selected\").Y.Offset), \"selected\", beforeName)\n\t\tif squareCorners then\n\t\t\tself:set(\"iconCornerRadius\", UDim.new(0, 0), \"deselected\", beforeName)\n\t\t\tself:set(\"iconCornerRadius\", UDim.new(0, 0), \"selected\", beforeName)\n\t\tend\n\t\tself:set(\"captionBlockerTransparency\", 0.4, nil, beforeName)\n\tend\n\tlocal array = parentIcon[newFeatureName..\"Icons\"]\n\ttable.insert(array, self)\n\tif not dontUpdate then\n\t\tparentIcon:_updateDropdown()\n\tend\n\tparentIcon.deselectWhenOtherIconSelected = false\n\t--\n\tIconController:_updateSelectionGroup()\n\tself:_decideToCallSignal(\"dropdown\")\n\tself:_decideToCallSignal(\"menu\")\n\t--\n\treturn self\nend\n\nfunction Icon:leave()\n\tif self._destroyed or self.instances.iconContainer.Parent == nil then\n\t\treturn\n\tend\n\tlocal settingsToReset = {\"iconSize\", \"captionBlockerTransparency\", \"iconCornerRadius\"}\n\tlocal parentIcon = self._parentIcon\n\tself.instances.iconContainer.Parent = topbarContainer\n\tself.presentOnTopbar = true\n\tself.joinedFeatureName = nil\n\tlocal function scanFeature(t, prevReference, updateMethod)\n\t\tfor i, otherIcon in pairs(t) do\n\t\t\tif otherIcon == self then\n\t\t\t\tfor _, settingName in pairs(settingsToReset) do\n\t\t\t\t\tlocal states = {\"deselected\", \"selected\"}\n\t\t\t\t\tfor _, toggleState in pairs(states) do\n\t\t\t\t\t\tlocal currentSetting, previousSetting = self:get(settingName, toggleState, prevReference)\n\t\t\t\t\t\tif previousSetting then\n\t\t\t\t\t\t\tself:set(settingName, previousSetting, toggleState)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\ttable.remove(t, i)\n\t\t\t\tupdateMethod(parentIcon)\n\t\t\t\tif #t == 0 then\n\t\t\t\t\tself._parentIcon.deselectWhenOtherIconSelected = true\n\t\t\t\tend\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tscanFeature(parentIcon.dropdownIcons, \"beforeDropdown\", parentIcon._updateDropdown)\n\tscanFeature(parentIcon.menuIcons, \"beforeMenu\", parentIcon._updateMenu)\n\t--\n\tfor noticeId, noticeDetail in pairs(self.notices) do\n\t\tlocal parentIconNoticeDetail = parentIcon.notices[noticeId]\n\t\tif parentIconNoticeDetail then\n\t\t\tparentIconNoticeDetail.completeSignal:Fire()\n\t\tend\n\tend\n\t--\n\tself._parentIcon = nil\n\t--\n\tIconController:_updateSelectionGroup()\n\tself:_decideToCallSignal(\"dropdown\")\n\tself:_decideToCallSignal(\"menu\")\n\t--\n\treturn self\nend\n\nfunction Icon:_decideToCallSignal(featureName)\n\tlocal isOpen = self[featureName..\"Open\"]\n\tlocal previousIsOpenName = \"_previous\"..string.sub(featureName, 1, 1):upper()..featureName:sub(2)..\"Open\"\n\tlocal previousIsOpen = self[previousIsOpenName]\n\tlocal totalIcons = #self[featureName..\"Icons\"]\n\tif isOpen and totalIcons > 0 and previousIsOpen == false then\n\t\tself[previousIsOpenName] = true\n\t\tself[featureName..\"Opened\"]:Fire()\n\telseif (not isOpen or totalIcons == 0) and previousIsOpen == true then\n\t\tself[previousIsOpenName] = false\n\t\tself[featureName..\"Closed\"]:Fire()\n\tend\nend\n\nfunction Icon:_ignoreClipping(featureName)\n\tlocal ignoreClipping = self:get(featureName..\"IgnoreClipping\")\n\tif self._parentIcon then\n\t\tlocal maid = self[\"_\"..featureName..\"ClippingMaid\"]\n\t\tlocal frame = self.instances[featureName..\"Container\"]\n\t\tmaid:clean()\n\t\tif ignoreClipping then\n\t\t\tlocal fakeFrame = Instance.new(\"Frame\")\n\t\t\tfakeFrame.Name = frame.Name..\"FakeFrame\"\n\t\t\tfakeFrame.ClipsDescendants = true\n\t\t\tfakeFrame.BackgroundTransparency = 1\n\t\t\tfakeFrame.Size = frame.Size\n\t\t\tfakeFrame.Position = frame.Position\n\t\t\tfakeFrame.Parent = activeItems\n\t\t\t--\n\t\t\tfor a,b in pairs(frame:GetChildren()) do\n\t\t\t\tb.Parent = fakeFrame\n\t\t\tend\n\t\t\t--\n\t\t\tlocal function updateSize()\n\t\t\t\tlocal absoluteSize = frame.AbsoluteSize\n\t\t\t\tfakeFrame.Size = UDim2.new(0, absoluteSize.X, 0, absoluteSize.Y)\n\t\t\tend\n\t\t\tmaid:give(frame:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\t\t\tupdateSize()\n\t\t\tend))\n\t\t\tupdateSize()\n\t\t\tlocal function updatePos()\n\t\t\t\tlocal absolutePosition = frame.absolutePosition\n\t\t\t\tfakeFrame.Position = UDim2.new(0, absolutePosition.X, 0, absolutePosition.Y+36)\n\t\t\tend\n\t\t\tmaid:give(frame:GetPropertyChangedSignal(\"AbsolutePosition\"):Connect(function()\n\t\t\t\tupdatePos()\n\t\t\tend))\n\t\t\tupdatePos()\n\t\t\tmaid:give(function()\n\t\t\t\tfor a,b in pairs(fakeFrame:GetChildren()) do\n\t\t\t\t\tb.Parent = frame\n\t\t\t\tend\n\t\t\t\tfakeFrame.Name = \"Destroying...\"\n\t\t\t\tfakeFrame:Destroy()\n\t\t\tend)\n\t\tend\n\tend\n\tself._ignoreClippingChanged:Fire(featureName, ignoreClipping)\nend\n\n-- Dropdowns\nfunction Icon:setDropdown(arrayOfIcons)\n\t-- Reset any previous icons\n\tfor i, otherIcon in pairs(self.dropdownIcons) do\n\t\totherIcon:leave()\n\tend\n\t-- Apply new icons\n\tif type(arrayOfIcons) == \"table\" then\n\t\tfor i, otherIcon in pairs(arrayOfIcons) do\n\t\t\totherIcon:join(self, \"dropdown\", true)\n\t\tend\n\tend\n\t-- Update dropdown\n\tself:_updateDropdown()\n\treturn self\nend\n\nfunction Icon:_updateDropdown()\n\tlocal values = {\n\t\tmaxIconsBeforeScroll = self:get(\"dropdownMaxIconsBeforeScroll\") or \"_NIL\",\n\t\tminWidth = self:get(\"dropdownMinWidth\") or \"_NIL\",\n\t\tpadding = self:get(\"dropdownListPadding\") or \"_NIL\",\n\t\tdropdownAlignment = self:get(\"dropdownAlignment\") or \"_NIL\",\n\t\ticonAlignment = self:get(\"alignment\") or \"_NIL\",\n\t\tscrollBarThickness = self:get(\"dropdownScrollBarThickness\") or \"_NIL\",\n\t}\n\tfor k, v in pairs(values) do if v == \"_NIL\" then return end end\n\t\n\tlocal YPadding = values.padding.Offset\n\tlocal dropdownContainer = self.instances.dropdownContainer\n\tlocal dropdownFrame = self.instances.dropdownFrame\n\tlocal dropdownList = self.instances.dropdownList\n\tlocal totalIcons = #self.dropdownIcons\n\n\tlocal lastVisibleIconIndex = (totalIcons > values.maxIconsBeforeScroll and values.maxIconsBeforeScroll) or totalIcons\n\tlocal newCanvasSizeY = -YPadding\n\tlocal newFrameSizeY = 0\n\tlocal newMinWidth = values.minWidth\n\ttable.sort(self.dropdownIcons, function(a,b) return a:get(\"order\") < b:get(\"order\") end)\n\tfor i = 1, totalIcons do\n\t\tlocal otherIcon = self.dropdownIcons[i]\n\t\tlocal _, otherIconSize = otherIcon:get(\"iconSize\", nil, \"beforeDropdown\")\n\t\tlocal increment = otherIconSize.Y.Offset + YPadding\n\t\tif i <= lastVisibleIconIndex then\n\t\t\tnewFrameSizeY = newFrameSizeY + increment\n\t\tend\n\t\tif i == totalIcons then\n\t\t\tnewFrameSizeY = newFrameSizeY + increment/4\n\t\tend\n\t\tnewCanvasSizeY = newCanvasSizeY + increment\n\t\tlocal otherIconWidth = otherIconSize.X.Offset --+ 4 + 100 -- the +100 is to allow for notices\n\t\tif otherIconWidth > newMinWidth then\n\t\t\tnewMinWidth = otherIconWidth\n\t\tend\n\tend\n\n\tlocal finalCanvasSizeY = (lastVisibleIconIndex == totalIcons and 0) or newCanvasSizeY\n\tself:set(\"dropdownCanvasSize\", UDim2.new(0, 0, 0, finalCanvasSizeY))\n\tself:set(\"dropdownSize\", UDim2.new(0, (newMinWidth+4)*2, 0, newFrameSizeY))\n\n\t-- Set alignment while considering screen bounds\n\tlocal dropdownAlignment = values.dropdownAlignment:lower()\n\tlocal alignmentDetails = {\n\t\tleft = {\n\t\t\tAnchorPoint = Vector2.new(0, 0),\n\t\t\tPositionXScale = 0,\n\t\t\tThicknessMultiplier = 0,\n\t\t},\n\t\tmid = {\n\t\t\tAnchorPoint = Vector2.new(0.5, 0),\n\t\t\tPositionXScale = 0.5,\n\t\t\tThicknessMultiplier = 0.5,\n\t\t},\n\t\tright = {\n\t\t\tAnchorPoint = Vector2.new(0.5, 0),\n\t\t\tPositionXScale = 1,\n\t\t\tFrameAnchorPoint = Vector2.new(0, 0),\n\t\t\tFramePositionXScale = 0,\n\t\t\tThicknessMultiplier = 1,\n\t\t}\n\t}\n\tlocal alignmentDetail = alignmentDetails[dropdownAlignment]\n\tif not alignmentDetail then\n\t\talignmentDetail = alignmentDetails[values.iconAlignment:lower()]\n\tend\n\tdropdownContainer.AnchorPoint = alignmentDetail.AnchorPoint\n\tdropdownContainer.Position = UDim2.new(alignmentDetail.PositionXScale, 0, 1, YPadding+0)\n\tlocal scrollbarThickness = values.scrollBarThickness\n\tlocal newThickness = scrollbarThickness * alignmentDetail.ThicknessMultiplier\n\tlocal additionalOffset = (dropdownFrame.VerticalScrollBarPosition == Enum.VerticalScrollBarPosition.Right and newThickness) or -newThickness\n\tdropdownFrame.AnchorPoint = alignmentDetail.FrameAnchorPoint or alignmentDetail.AnchorPoint\n\tdropdownFrame.Position = UDim2.new(alignmentDetail.FramePositionXScale or alignmentDetail.PositionXScale, additionalOffset, 0, 0)\n\tself._dropdownCanvasPos = Vector2.new(0, 0)\nend\n\nfunction Icon:_dropdownIgnoreClipping()\n\tself:_ignoreClipping(\"dropdown\")\nend\n\n\n-- Menus\nfunction Icon:setMenu(arrayOfIcons)\n\t-- Reset any previous icons\n\tfor i, otherIcon in pairs(self.menuIcons) do\n\t\totherIcon:leave()\n\tend\n\t-- Apply new icons\n\tif type(arrayOfIcons) == \"table\" then\n\t\tfor i, otherIcon in pairs(arrayOfIcons) do\n\t\t\totherIcon:join(self, \"menu\", true)\n\t\tend\n\tend\n\t-- Update menu\n\tself:_updateMenu()\n\treturn self\nend\n\nfunction Icon:_getMenuDirection()\n\tlocal direction = (self:get(\"menuDirection\") or \"_NIL\"):lower()\n\tlocal alignment = (self:get(\"alignment\") or \"_NIL\"):lower()\n\tif direction ~= \"left\" and direction ~= \"right\" then\n\t\tdirection = (alignment == \"left\" and \"right\") or \"left\" \n\tend\n\treturn direction\nend\n\nfunction Icon:_updateMenu()\n\tlocal values = {\n\t\tmaxIconsBeforeScroll = self:get(\"menuMaxIconsBeforeScroll\") or \"_NIL\",\n\t\tdirection = self:get(\"menuDirection\") or \"_NIL\",\n\t\ticonAlignment = self:get(\"alignment\") or \"_NIL\",\n\t\tscrollBarThickness = self:get(\"menuScrollBarThickness\") or \"_NIL\",\n\t}\n\tfor k, v in pairs(values) do if v == \"_NIL\" then return end end\n\t\n\tlocal XPadding = IconController[values.iconAlignment..\"Gap\"]--12\n\tlocal menuContainer = self.instances.menuContainer\n\tlocal menuFrame = self.instances.menuFrame\n\tlocal menuList = self.instances.menuList\n\tlocal totalIcons = #self.menuIcons\n\n\tlocal direction = self:_getMenuDirection()\n\tlocal lastVisibleIconIndex = (totalIcons > values.maxIconsBeforeScroll and values.maxIconsBeforeScroll) or totalIcons\n\tlocal newCanvasSizeX = -XPadding\n\tlocal newFrameSizeX = 0\n\tlocal newMinHeight = 0\n\tlocal sortFunc = (direction == \"right\" and function(a,b) return a:get(\"order\") < b:get(\"order\") end) or function(a,b) return a:get(\"order\") > b:get(\"order\") end\n\ttable.sort(self.menuIcons, sortFunc)\n\tfor i = 1, totalIcons do\n\t\tlocal otherIcon = self.menuIcons[i]\n\t\tlocal otherIconSize = otherIcon:get(\"iconSize\")\n\t\tlocal increment = otherIconSize.X.Offset + XPadding\n\t\tif i <= lastVisibleIconIndex then\n\t\t\tnewFrameSizeX = newFrameSizeX + increment\n\t\tend\n\t\tif i == lastVisibleIconIndex and i ~= totalIcons then\n\t\t\tnewFrameSizeX = newFrameSizeX -2--(increment/4)\n\t\tend\n\t\tnewCanvasSizeX = newCanvasSizeX + increment\n\t\tlocal otherIconHeight = otherIconSize.Y.Offset\n\t\tif otherIconHeight > newMinHeight then\n\t\t\tnewMinHeight = otherIconHeight\n\t\tend\n\tend\n\n\tlocal canvasSize = (lastVisibleIconIndex == totalIcons and 0) or newCanvasSizeX + XPadding\n\tself:set(\"menuCanvasSize\", UDim2.new(0, canvasSize, 0, 0))\n\tself:set(\"menuSize\", UDim2.new(0, newFrameSizeX, 0, newMinHeight + values.scrollBarThickness + 3))\n\n\t-- Set direction\n\tlocal directionDetails = {\n\t\tleft = {\n\t\t\tcontainerAnchorPoint = Vector2.new(1, 0),\n\t\t\tcontainerPosition = UDim2.new(0, -4, 0, 0),\n\t\t\tcanvasPosition = Vector2.new(canvasSize, 0)\n\t\t},\n\t\tright = {\n\t\t\tcontainerAnchorPoint = Vector2.new(0, 0),\n\t\t\tcontainerPosition = UDim2.new(1, XPadding-2, 0, 0),\n\t\t\tcanvasPosition = Vector2.new(0, 0),\n\t\t}\n\t}\n\tlocal directionDetail = directionDetails[direction]\n\tmenuContainer.AnchorPoint = directionDetail.containerAnchorPoint\n\tmenuContainer.Position = directionDetail.containerPosition\n\tmenuFrame.CanvasPosition = directionDetail.canvasPosition\n\tself._menuCanvasPos = directionDetail.canvasPosition\n\n\tmenuList.Padding = UDim.new(0, XPadding)\nend\n\nfunction Icon:_menuIgnoreClipping()\n\tself:_ignoreClipping(\"menu\")\nend\n\n\n\n-- DESTROY/CLEANUP METHOD\nfunction Icon:destroy()\n\tif self._destroyed then return end\n\tIconController.iconRemoved:Fire(self)\n\tself:clearNotices()\n\tif self._parentIcon then\n\t\tself:leave()\n\tend\n\tself:setDropdown()\n\tself:setMenu()\n\tself._destroyed = true\n\tself._maid:clean()\nend\nIcon.Destroy = Icon.destroy -- an alias for you maid-using Pascal lovers\n\n\n\nreturn Icon\n"

local VERSION = Instance.new("ModuleScript")
VERSION.Name = "VERSION"
VERSION.Source = "return \"v2.7.6\""
VERSION.Parent = Icon

local TopbarPlusReference = Instance.new("ModuleScript")
TopbarPlusReference.Name = "TopbarPlusReference"
TopbarPlusReference.Source = "-- This module enables you to place Icon wherever you like within the data model while\n-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it\n-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would\n-- cause icons to overlap with each other\n\nlocal replicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal TopbarPlusReference = {}\n\nfunction TopbarPlusReference.addToReplicatedStorage()\n    local existingItem = replicatedStorage:FindFirstChild(script.Name)\n    if existingItem then\n        return false\n    end\n    local objectValue = Instance.new(\"ObjectValue\")\n    objectValue.Name = script.Name\n    objectValue.Value = script.Parent\n    objectValue.Parent = replicatedStorage\n    return objectValue\nend\n\nfunction TopbarPlusReference.getObject()\n    local objectValue = replicatedStorage:FindFirstChild(script.Name)\n    if objectValue then\n        return objectValue\n    end\n    return false\nend\n\nreturn TopbarPlusReference"
TopbarPlusReference.Parent = Icon

local TopbarPlusGui = Instance.new("ModuleScript")
TopbarPlusGui.Name = "TopbarPlusGui"
TopbarPlusGui.Source = "-- SETUP ICON TEMPLATE\nlocal topbarPlusGui = Instance.new(\"ScreenGui\")\ntopbarPlusGui.Enabled = true\ntopbarPlusGui.DisplayOrder = 0\ntopbarPlusGui.IgnoreGuiInset = true\ntopbarPlusGui.ResetOnSpawn = false\ntopbarPlusGui.Name = \"TopbarPlus\"\n\nlocal activeItems = Instance.new(\"Folder\")\nactiveItems.Name = \"ActiveItems\"\nactiveItems.Parent = topbarPlusGui\n\nlocal topbarContainer = Instance.new(\"Frame\")\ntopbarContainer.BackgroundTransparency = 1\ntopbarContainer.Name = \"TopbarContainer\"\ntopbarContainer.Position = UDim2.new(0, 0, 0, 0)\ntopbarContainer.Size = UDim2.new(1, 0, 0, 36)\ntopbarContainer.Visible = true\ntopbarContainer.ZIndex = 1\ntopbarContainer.Parent = topbarPlusGui\ntopbarContainer.Active = false\n\nlocal iconContainer = Instance.new(\"Frame\")\niconContainer.BackgroundTransparency = 1\niconContainer.Name = \"IconContainer\"\niconContainer.Position = UDim2.new(0, 104, 0, 4)\niconContainer.Visible = false\niconContainer.ZIndex = 1\niconContainer.Parent = topbarContainer\niconContainer.Active = false\n\nlocal iconButton = Instance.new(\"TextButton\")\niconButton.Name = \"IconButton\"\niconButton.Visible = true\niconButton.Text = \"\"\niconButton.ZIndex = 10--2\niconButton.BorderSizePixel = 0\niconButton.AutoButtonColor = false\niconButton.Parent = iconContainer\niconButton.Active = true\n\nlocal iconImage = Instance.new(\"ImageLabel\")\niconImage.BackgroundTransparency = 1\niconImage.Name = \"IconImage\"\niconImage.AnchorPoint = Vector2.new(0, 0.5)\niconImage.Visible = true\niconImage.ZIndex = 11--3\niconImage.ScaleType = Enum.ScaleType.Fit\niconImage.Parent = iconButton\niconImage.Active = false\n\nlocal iconLabel = Instance.new(\"TextLabel\")\niconLabel.BackgroundTransparency = 1\niconLabel.Name = \"IconLabel\"\niconLabel.AnchorPoint = Vector2.new(0, 0.5)\niconLabel.Position = UDim2.new(0.5, 0, 0.5, 0)\niconLabel.Text = \"\"\niconLabel.RichText = true\niconLabel.TextScaled = false\niconLabel.ClipsDescendants = true\niconLabel.ZIndex = 11--3\niconLabel.Parent = iconButton\niconLabel.Active = false\n\nlocal iconGradient = Instance.new(\"UIGradient\")\niconGradient.Name = \"IconGradient\"\niconGradient.Enabled = true\niconGradient.Parent = iconButton\n\nlocal iconCorner = Instance.new(\"UICorner\")\niconCorner.Name = \"IconCorner\"\niconCorner.Parent = iconButton\n\nlocal iconOverlay = Instance.new(\"Frame\")\niconOverlay.Name = \"IconOverlay\"\niconOverlay.BackgroundTransparency = 1\niconOverlay.Position = iconButton.Position\niconOverlay.Size = UDim2.new(1, 0, 1, 0)\niconOverlay.Visible = true\niconOverlay.ZIndex = iconButton.ZIndex + 1\niconOverlay.BorderSizePixel = 0\niconOverlay.Parent = iconContainer\niconOverlay.Active = false\n\nlocal iconOverlayCorner = iconCorner:Clone()\niconOverlayCorner.Name = \"IconOverlayCorner\"\niconOverlayCorner.Parent = iconOverlay\n\n\n-- Notice prompts\nlocal noticeFrame = Instance.new(\"ImageLabel\")\nnoticeFrame.BackgroundTransparency = 1\nnoticeFrame.Name = \"NoticeFrame\"\nnoticeFrame.Position = UDim2.new(0.45, 0, 0, -2)\nnoticeFrame.Size = UDim2.new(1, 0, 0.7, 0)\nnoticeFrame.Visible = true\nnoticeFrame.ZIndex = 12--4\nnoticeFrame.ImageTransparency = 1\nnoticeFrame.ScaleType = Enum.ScaleType.Fit\nnoticeFrame.Parent = iconButton\nnoticeFrame.Active = false\n\nlocal noticeLabel = Instance.new(\"TextLabel\")\nnoticeLabel.Name = \"NoticeLabel\"\nnoticeLabel.BackgroundTransparency = 1\nnoticeLabel.Position = UDim2.new(0.25, 0, 0.15, 0)\nnoticeLabel.Size = UDim2.new(0.5, 0, 0.7, 0)\nnoticeLabel.Visible = true\nnoticeLabel.ZIndex = 13--5\nnoticeLabel.Font = Enum.Font.Arial\nnoticeLabel.Text = \"0\"\nnoticeLabel.TextTransparency = 1\nnoticeLabel.TextScaled = true\nnoticeLabel.Parent = noticeFrame\nnoticeLabel.Active = false\n\n\n-- Captions\nlocal captionContainer = Instance.new(\"Frame\")\ncaptionContainer.Name = \"CaptionContainer\"\ncaptionContainer.BackgroundTransparency = 1\ncaptionContainer.AnchorPoint = Vector2.new(0, 0)\ncaptionContainer.ClipsDescendants = true\ncaptionContainer.ZIndex = 30\ncaptionContainer.Visible = true\ncaptionContainer.Parent = iconContainer\ncaptionContainer.Active = false\n\nlocal captionFrame = Instance.new(\"Frame\")\ncaptionFrame.Name = \"CaptionFrame\"\ncaptionFrame.BorderSizePixel = 0\ncaptionFrame.AnchorPoint = Vector2.new(0.5,0.5)\ncaptionFrame.Position = UDim2.new(0.5,0,0.5,0)\ncaptionFrame.Size = UDim2.new(1,0,1,0)\ncaptionFrame.ZIndex = 31\ncaptionFrame.Parent = captionContainer\ncaptionFrame.Active = false\n\nlocal captionLabel = Instance.new(\"TextLabel\")\ncaptionLabel.Name = \"CaptionLabel\"\ncaptionLabel.BackgroundTransparency = 1\ncaptionLabel.AnchorPoint = Vector2.new(0.5,0.5)\ncaptionLabel.Position = UDim2.new(0.5,0,0.56,0)\ncaptionLabel.TextXAlignment = Enum.TextXAlignment.Center\ncaptionLabel.RichText = true\ncaptionLabel.ZIndex = 32\ncaptionLabel.Parent = captionContainer\ncaptionLabel.Active = false\n\nlocal captionCorner = Instance.new(\"UICorner\")\ncaptionCorner.Name = \"CaptionCorner\"\ncaptionCorner.Parent = captionFrame\n\nlocal captionOverlineContainer = Instance.new(\"Frame\")\ncaptionOverlineContainer.Name = \"CaptionOverlineContainer\"\ncaptionOverlineContainer.BackgroundTransparency = 1\ncaptionOverlineContainer.AnchorPoint = Vector2.new(0.5,0.5)\ncaptionOverlineContainer.Position = UDim2.new(0.5,0,-0.5,3)\ncaptionOverlineContainer.Size = UDim2.new(1,0,1,0)\ncaptionOverlineContainer.ZIndex = 33\ncaptionOverlineContainer.ClipsDescendants = true\ncaptionOverlineContainer.Parent = captionContainer\ncaptionOverlineContainer.Active = false\n\nlocal captionOverline = Instance.new(\"Frame\")\ncaptionOverline.Name = \"CaptionOverline\"\ncaptionOverline.AnchorPoint = Vector2.new(0.5,0.5)\ncaptionOverline.Position = UDim2.new(0.5,0,1.5,-3)\ncaptionOverline.Size = UDim2.new(1,0,1,0)\ncaptionOverline.ZIndex = 34\ncaptionOverline.Parent = captionOverlineContainer\ncaptionOverline.Active = false\n\nlocal captionOverlineCorner = captionCorner:Clone()\ncaptionOverlineCorner.Name = \"CaptionOverlineCorner\"\ncaptionOverlineCorner.Parent = captionOverline\n\nlocal captionVisibilityBlocker = captionFrame:Clone()\ncaptionVisibilityBlocker.Name = \"CaptionVisibilityBlocker\"\ncaptionVisibilityBlocker.BackgroundTransparency = 1\ncaptionVisibilityBlocker.BackgroundColor3 = Color3.fromRGB(50, 50, 50)\ncaptionVisibilityBlocker.ZIndex -= 1\ncaptionVisibilityBlocker.Parent = captionFrame\ncaptionVisibilityBlocker.Active = false\n\nlocal captionVisibilityCorner = captionVisibilityBlocker.CaptionCorner\ncaptionVisibilityCorner.Name = \"CaptionVisibilityCorner\"\n\n\n-- Tips\nlocal tipFrame = Instance.new(\"Frame\")\ntipFrame.Name = \"TipFrame\"\ntipFrame.BorderSizePixel = 0\ntipFrame.AnchorPoint = Vector2.new(0, 0)\ntipFrame.Position = UDim2.new(0,50,0,50)\ntipFrame.Size = UDim2.new(1,0,1,-8)\ntipFrame.ZIndex = 40\ntipFrame.Parent = iconContainer\ntipFrame.Active = false\n\nlocal tipCorner = Instance.new(\"UICorner\")\ntipCorner.Name = \"TipCorner\"\ntipCorner.CornerRadius = UDim.new(0.25,0)\ntipCorner.Parent = tipFrame\n\nlocal tipLabel = Instance.new(\"TextLabel\")\ntipLabel.Name = \"TipLabel\"\ntipLabel.BackgroundTransparency = 1\ntipLabel.TextScaled = false\ntipLabel.TextSize = 12\ntipLabel.Position = UDim2.new(0,3,0,3)\ntipLabel.Size = UDim2.new(1,-6,1,-6)\ntipLabel.ZIndex = 41\ntipLabel.Parent = tipFrame\ntipLabel.Active = false\n\n\n-- Dropdowns\nlocal dropdownContainer = Instance.new(\"Frame\")\ndropdownContainer.Name = \"DropdownContainer\"\ndropdownContainer.BackgroundTransparency = 1\ndropdownContainer.BorderSizePixel = 0\ndropdownContainer.AnchorPoint = Vector2.new(0.5, 0)\ndropdownContainer.ZIndex = -2\ndropdownContainer.ClipsDescendants = true\ndropdownContainer.Visible = true\ndropdownContainer.Parent = iconContainer\ndropdownContainer.Active = false\n\nlocal dropdownFrame = Instance.new(\"ScrollingFrame\")\ndropdownFrame.Name = \"DropdownFrame\"\ndropdownFrame.BackgroundTransparency = 1\ndropdownFrame.BorderSizePixel = 0\ndropdownFrame.AnchorPoint = Vector2.new(0.5, 0)\ndropdownFrame.Position = UDim2.new(0.5, 0, 0, 0)\ndropdownFrame.Size = UDim2.new(0.5, 2, 1, 0)\ndropdownFrame.ZIndex = -1\ndropdownFrame.ClipsDescendants = false\ndropdownFrame.Visible = true\ndropdownFrame.TopImage = dropdownFrame.MidImage\ndropdownFrame.BottomImage = dropdownFrame.MidImage\ndropdownFrame.VerticalScrollBarInset = Enum.ScrollBarInset.Always\ndropdownFrame.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right\ndropdownFrame.Parent = dropdownContainer\ndropdownFrame.Active = false\n\nlocal dropdownList = Instance.new(\"UIListLayout\")\ndropdownList.Name = \"DropdownList\"\ndropdownList.FillDirection = Enum.FillDirection.Vertical\ndropdownList.SortOrder = Enum.SortOrder.LayoutOrder\ndropdownList.Parent = dropdownFrame\n\nlocal dropdownPadding = Instance.new(\"UIPadding\")\ndropdownPadding.Name = \"DropdownPadding\"\ndropdownPadding.PaddingRight = UDim.new(0, 2)\ndropdownPadding.Parent = dropdownFrame\n\n\n-- Menus\nlocal menuContainer = Instance.new(\"Frame\")\nmenuContainer.Active = true\nmenuContainer.Selectable = false\nmenuContainer.Name = \"MenuContainer\"\nmenuContainer.BackgroundTransparency = 1\nmenuContainer.BorderSizePixel = 0\nmenuContainer.AnchorPoint = Vector2.new(1, 0)\nmenuContainer.Size = UDim2.new(0, 500, 0, 50)\nmenuContainer.ZIndex = -2\nmenuContainer.ClipsDescendants = true\nmenuContainer.Visible = true\nmenuContainer.Parent = iconContainer\nmenuContainer.Active = false\n\nlocal menuFrame = Instance.new(\"ScrollingFrame\")\nmenuFrame.Active = true\nmenuFrame.Selectable = true\nmenuFrame.Name = \"MenuFrame\"\nmenuFrame.BackgroundTransparency = 1\nmenuFrame.BorderSizePixel = 0\nmenuFrame.AnchorPoint = Vector2.new(0, 0)\nmenuFrame.Position = UDim2.new(0, 0, 0, 0)\nmenuFrame.Size = UDim2.new(1, 0, 1, 0)\nmenuFrame.ZIndex = -1 + 10\nmenuFrame.ClipsDescendants = false\nmenuFrame.Visible = true\nmenuFrame.TopImage = \"\"--menuFrame.MidImage\nmenuFrame.BottomImage = \"\"--menuFrame.MidImage\nmenuFrame.HorizontalScrollBarInset = Enum.ScrollBarInset.Always\nmenuFrame.CanvasSize = UDim2.new(0, 0, 0, 0)\nmenuFrame.Parent = menuContainer\nmenuFrame.Active = false\n\nlocal menuList = Instance.new(\"UIListLayout\")\nmenuList.Name = \"MenuList\"\nmenuList.FillDirection = Enum.FillDirection.Horizontal\nmenuList.HorizontalAlignment = Enum.HorizontalAlignment.Right\nmenuList.SortOrder = Enum.SortOrder.LayoutOrder\nmenuList.Parent = menuFrame\n\nlocal menuInvisBlocker = Instance.new(\"Frame\")\nmenuInvisBlocker.Name = \"MenuInvisBlocker\"\nmenuInvisBlocker.BackgroundTransparency = 1\nmenuInvisBlocker.Size = UDim2.new(0, -2, 1, 0)\nmenuInvisBlocker.Visible = true\nmenuInvisBlocker.LayoutOrder = 999999999\nmenuInvisBlocker.Parent = menuFrame\nmenuInvisBlocker.Active = false\n\n\n-- Click Sound\nlocal clickSound = Instance.new(\"Sound\")\nclickSound.Name = \"ClickSound\"\nclickSound.Volume = 0\nclickSound.Parent = iconContainer\n\n\n-- Other\nlocal indicator = Instance.new(\"ImageLabel\")\nindicator.Name = \"Indicator\"\nindicator.BackgroundTransparency = 1\nindicator.Image = \"rbxassetid://5278151556\"\nindicator.Size = UDim2.new(0,32,0,32)\nindicator.AnchorPoint = Vector2.new(0.5,0)\nindicator.Position = UDim2.new(0.5,0,0,5)\nindicator.ScaleType = Enum.ScaleType.Fit\nindicator.Visible = false\nindicator.Active = true\nindicator.Parent = topbarPlusGui\nindicator.Active = false\n\n\n\n-- PARENT\nlocal localPlayer = game:GetService(\"Players\").LocalPlayer\nlocal playerGui = localPlayer.PlayerGui\ntopbarPlusGui.Parent = playerGui\n\n\n\nreturn topbarPlusGui"
TopbarPlusGui.Parent = Icon

local Themes = Instance.new("ModuleScript")
Themes.Name = "Themes"
Themes.Source = "-- Require all children and return their references\nlocal Themes = {}\nfor _, module in pairs(script:GetChildren()) do\n    if module:IsA(\"ModuleScript\") then\n        Themes[module.Name] = require(module)\n    end\nend\nreturn Themes"
Themes.Parent = Icon

local Default = Instance.new("ModuleScript")
Default.Name = "Default"
Default.Source = "--[[\nThis file is necessary for constructing the default Icon template\nDo not remove this module otherwise TopbarPlus will break\nModifying this file may also cause TopbarPlus to break\nIt's recommended instead to create a separate theme module and use that instead\n\nTo apply your theme after creating it, do:\n```lua\nlocal IconController = require(pathway.to.IconController)\nlocal Themes = require(pathway.to.Themes)\nIconController.setGameTheme(Themes.YourThemeName)\n```\n\nor by applying to an individual icon:\n```lua\nlocal Icon = require(pathway.to.Icon)\nlocal Themes = require(pathway.to.Themes)\nlocal newIcon = Icon.new()\n    :setTheme(Themes.YourThemeName)\n```\n--]]\n\nreturn {\n    \n    -- Settings which describe how an item behaves or transitions between states\n    action =  {\n        toggleTransitionInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        resizeInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        repositionInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        captionFadeInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        tipFadeInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        dropdownSlideInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n        menuSlideInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),\n    },\n\n    -- Settings which describe how an item appears when 'deselected' and 'selected'\n    toggleable = {\n        -- How items appear normally (i.e. when they're 'deselected')\n        deselected = {\n            iconBackgroundColor = Color3.fromRGB(0, 0, 0),\n            iconBackgroundTransparency = 0.5,\n            iconCornerRadius = UDim.new(0.25, 0),\n            iconGradientColor = ColorSequence.new(Color3.fromRGB(255, 255, 255)),\n            iconGradientRotation = 0,\n            iconImage = \"\",\n            iconImageColor =Color3.fromRGB(255, 255, 255),\n            iconImageTransparency = 0,\n            iconImageYScale = 0.63,\n            iconImageRatio = 1,\n            iconLabelYScale = 0.45,\n            iconScale = UDim2.new(1, 0, 1, 0),\n            forcedIconSize = UDim2.new(0, 32, 0, 32);\n            iconSize = UDim2.new(0, 32, 0, 32),\n            iconOffset = UDim2.new(0, 0, 0, 0),\n            iconText = \"\",\n            iconTextColor = Color3.fromRGB(255, 255, 255),\n            iconFont = Enum.Font.GothamSemibold,\n            noticeCircleColor = Color3.fromRGB(255, 255, 255),\n            noticeCircleImage = \"http://www.roblox.com/asset/?id=4871790969\",\n            noticeTextColor = Color3.fromRGB(31, 33, 35),\n            baseZIndex = 1,\n            order = 1,\n            alignment = \"left\",\n            clickSoundId = \"rbxassetid://5273899897\",\n            clickVolume = 0,\n            clickPlaybackSpeed = 1,\n            clickTimePosition = 0.12\n        },\n        -- How items appear after the icon has been clicked (i.e. when they're 'selected')\n        -- If a selected value is not specified, it will default to the deselected value\n        selected = {\n            iconBackgroundColor = Color3.fromRGB(245, 245, 245),\n            iconBackgroundTransparency = 0.1,\n            iconImageColor = Color3.fromRGB(57, 60, 65),\n            iconTextColor = Color3.fromRGB(57, 60, 65),\n            clickPlaybackSpeed = 1.5,\n        }\n    },\n\n    -- Settings where toggleState doesn't matter (they have a singular state)\n    other = {\n        -- Caption settings\n        captionBackgroundColor = Color3.fromRGB(0, 0, 0),\n        captionBackgroundTransparency = 0.5,\n        captionTextColor = Color3.fromRGB(255, 255, 255),\n        captionTextTransparency = 0,\n        captionFont = Enum.Font.GothamSemibold,\n        captionOverlineColor = Color3.fromRGB(0, 170, 255),\n        captionOverlineTransparency = 0,\n        captionCornerRadius = UDim.new(0.25, 0),\n        -- Tip settings\n        tipBackgroundColor = Color3.fromRGB(255, 255, 255),\n        tipBackgroundTransparency = 0.1,\n        tipTextColor = Color3.fromRGB(27, 42, 53),\n        tipTextTransparency = 0,\n        tipFont = Enum.Font.GothamSemibold,\n        tipCornerRadius = UDim.new(0.175, 0),\n        -- Dropdown settings\n        dropdownAlignment = \"auto\", -- 'left', 'mid', 'right' or 'auto' (auto is where the dropdown alignment matches the icons alignment)\n        dropdownMaxIconsBeforeScroll = 3,\n        dropdownMinWidth = 32,\n        dropdownSquareCorners = false,\n        dropdownBindToggleToIcon = true,\n        dropdownToggleOnLongPress = false,\n        dropdownToggleOnRightClick = false,\n        dropdownCloseOnTapAway = false,\n        dropdownHidePlayerlistOnOverlap = true,\n        dropdownListPadding = UDim.new(0, 2),\n        dropdownScrollBarColor = Color3.fromRGB(25, 25, 25),\n        dropdownScrollBarTransparency = 0.2,\n        dropdownScrollBarThickness = 4,\n        -- Menu settings\n        menuDirection = \"auto\", -- 'left', 'right' or 'auto' (for auto, if alignment is 'left' or 'mid', menuDirection will be 'right', else menuDirection is 'left')\n        menuMaxIconsBeforeScroll = 4,\n        menuBindToggleToIcon = true,\n        menuToggleOnLongPress = false,\n        menuToggleOnRightClick = false,\n        menuCloseOnTapAway = false,\n        menuScrollBarColor = Color3.fromRGB(25, 25, 25),\n        menuScrollBarTransparency = 0.2,\n        menuScrollBarThickness = 4,\n    },\n    \n}"
Default.Parent = Themes

local BlueGradient = Instance.new("ModuleScript")
BlueGradient.Name = "BlueGradient"
BlueGradient.Source = "-- BlueGradient by ForeverHD\nlocal selectedColor = Color3.fromRGB(0, 170, 255)\nlocal selectedColorDarker = Color3.fromRGB(0, 120, 180)\nlocal neutralColor = Color3.fromRGB(255, 255, 255)\nreturn {\n    \n    -- Settings which describe how an item behaves or transitions between states\n    action =  {\n        resizeInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back),\n        repositionInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back),\n    },\n    \n    -- Settings which describe how an item appears when 'deselected' and 'selected'\n    toggleable = {\n        -- How items appear normally (i.e. when they're 'deselected')\n        deselected = {\n            iconGradientColor = ColorSequence.new(selectedColor, selectedColorDarker),\n            iconGradientRotation = 90,\n            noticeCircleColor = selectedColor,\n            noticeCircleImage = \"http://www.roblox.com/asset/?id=4882430005\",\n            noticeTextColor = neutralColor,\n            captionOverlineColor = selectedColor,\n        },\n        -- How items appear after the icon has been clicked (i.e. when they're 'selected')\n        -- If a selected value is not specified, it will default to the deselected value\n        selected = {\n            iconBackgroundColor = Color3.fromRGB(255, 255, 255),\n            iconBackgroundTransparency = 0.1,\n            iconGradientColor = ColorSequence.new(selectedColor, selectedColorDarker),\n            iconGradientRotation = 90,\n            iconImageColor = Color3.fromRGB(255, 255, 255),\n            iconTextColor = Color3.fromRGB(255, 255, 255),\n            noticeCircleColor = neutralColor,\n            noticeTextColor = selectedColor,\n        }\n    },\n    \n    -- Settings where toggleState doesn't matter (they have a singular state)\n    other =  {},\n    \n}\n"
BlueGradient.Parent = Themes

local Signal = Instance.new("ModuleScript")
Signal.Name = "Signal"
Signal.Source = "--[=[\n\tA class which holds data and methods for ScriptSignals.\n\n\t@class ScriptSignal\n]=]\nlocal ScriptSignal = {}\nScriptSignal.__index = ScriptSignal\n\n--[=[\n\tA class which holds data and methods for ScriptConnections.\n\n\t@class ScriptConnection\n]=]\nlocal ScriptConnection = {}\nScriptConnection.__index = ScriptConnection\n\n--[=[\n\tA boolean which determines if a ScriptConnection is active or not.\n\n\t@prop Connected boolean\n\t@within ScriptConnection\n\n\t@readonly\n\t@ignore\n]=]\n\n\nexport type Class = typeof( setmetatable({\n\t_active = true,\n\t_head = nil :: ScriptConnectionNode?\n}, ScriptSignal) )\n\nexport type ScriptConnection = typeof( setmetatable({\n\tConnected = true,\n\t_node = nil :: ScriptConnectionNode?\n}, ScriptConnection) )\n\ntype ScriptConnectionNode = {\n\t_signal: Class,\n\t_connection: ScriptConnection?,\n\t_handler: (...any) -> (),\n\n\t_next: ScriptConnectionNode?,\n\t_prev: ScriptConnectionNode?\n}\n\n\nlocal FreeThread: thread? = nil\n\nlocal function RunHandlerInFreeThread(handler, ...)\n\tlocal thread = FreeThread :: thread\n\tFreeThread = nil\n\n\thandler(...)\n\n\tFreeThread = thread\nend\n\nlocal function CreateFreeThread()\n\tFreeThread = coroutine.running()\n\n\twhile true do\n\t\tRunHandlerInFreeThread( coroutine.yield() )\n\tend\nend\n\n--[=[\n\tCreates a ScriptSignal object.\n\n\t@return ScriptSignal\n\t@ignore\n]=]\nfunction ScriptSignal.new(): Class\n\treturn setmetatable({\n\t\t_active = true,\n\t\t_head = nil\n\t}, ScriptSignal)\nend\n\n--[=[\n\tReturns a boolean determining if the object is a ScriptSignal.\n\n\t```lua\n\tlocal janitor = Janitor.new()\n\tlocal signal = ScriptSignal.new()\n\n\tScriptSignal.Is(signal) -> true\n\tScriptSignal.Is(janitor) -> false\n\t```\n\n\t@param object any\n\t@return boolean\n\t@ignore\n]=]\nfunction ScriptSignal.Is(object): boolean\n\treturn typeof(object) == 'table'\n\t\tand getmetatable(object) == ScriptSignal\nend\n\n--[=[\n\tReturns a boolean determing if a ScriptSignal object is active.\n\n\t```lua\n\tScriptSignal:IsActive() -> true\n\tScriptSignal:Destroy()\n\tScriptSignal:IsActive() -> false\n\t```\n\n\t@return boolean\n\t@ignore\n]=]\nfunction ScriptSignal:IsActive(): boolean\n\treturn self._active == true\nend\n\n--[=[\n\tConnects a handler to a ScriptSignal object.\n\n\t```lua\n\tScriptSignal:Connect(function(text)\n\t\tprint(text)\n\tend)\n\n\tScriptSignal:Fire(\"Something\")\n\tScriptSignal:Fire(\"Something else\")\n\n\t-- \"Something\" and then \"Something else\" are printed\n\t```\n\n\t@param handler (...: any) -> ()\n\t@return ScriptConnection\n\t@ignore\n]=]\nfunction ScriptSignal:Connect(\n\thandler: (...any) -> ()\n): ScriptConnection\n\n\tassert(\n\t\ttypeof(handler) == 'function',\n\t\t\"Must be function\"\n\t)\n\n\tif self._active ~= true then\n\t\treturn setmetatable({\n\t\t\tConnected = false,\n\t\t\t_node = nil\n\t\t}, ScriptConnection)\n\tend\n\n\tlocal _head: ScriptConnectionNode? = self._head\n\n\tlocal node: ScriptConnectionNode = {\n\t\t_signal = self :: Class,\n\t\t_connection = nil,\n\t\t_handler = handler,\n\n\t\t_next = _head,\n\t\t_prev = nil\n\t}\n\n\tif _head ~= nil then\n\t\t_head._prev = node\n\tend\n\n\tself._head = node\n\n\tlocal connection = setmetatable({\n\t\tConnected = true,\n\t\t_node = node\n\t}, ScriptConnection)\n\n\tnode._connection = connection\n\n\treturn connection :: ScriptConnection\nend\n\n--[=[\n\tConnects a handler to a ScriptSignal object, but only allows that\n\tconnection to run once. Any `:Fire` calls called afterwards won't trigger anything.\n\n\t```lua\n\tScriptSignal:ConnectOnce(function()\n\t\tprint(\"Connection fired\")\n\tend)\n\n\tScriptSignal:Fire()\n\tScriptSignal:Fire()\n\n\t-- \"Connection fired\" is only fired once\n\t```\n\n\t@param handler (...: any) -> ()\n\t@ignore\n]=]\nfunction ScriptSignal:ConnectOnce(\n\thandler: (...any) -> ()\n)\n\tassert(\n\t\ttypeof(handler) == 'function',\n\t\t\"Must be function\"\n\t)\n\n\tlocal connection\n\tconnection = self:Connect(function(...)\n\t\tconnection:Disconnect()\n\t\thandler(...)\n\tend)\nend\n\n--[=[\n\tYields the thread until a `:Fire` call occurs, returns what the signal was fired with.\n\n\t```lua\n\ttask.spawn(function()\n\t\tprint(\n\t\t\tScriptSignal:Wait()\n\t\t)\n\tend)\n\n\tScriptSignal:Fire(\"Arg\", nil, 1, 2, 3, nil)\n\t-- \"Arg\", nil, 1, 2, 3, nil are printed\n\t```\n\n\t@yields\n\t@return ...any\n\t@ignore\n]=]\nfunction ScriptSignal:Wait(): (...any)\n\tlocal thread do\n\t\tthread = coroutine.running()\n\n\t\tlocal connection\n\t\tconnection = self:Connect(function(...)\n\t\t\tconnection:Disconnect()\n\t\t\ttask.spawn(thread, ...)\n\t\tend)\n\tend\n\n\treturn coroutine.yield()\nend\n\n--[=[\n\tFires a ScriptSignal object with the arguments passed.\n\n\t```lua\n\tScriptSignal:Connect(function(text)\n\t\tprint(text)\n\tend)\n\n\tScriptSignal:Fire(\"Some Text...\")\n\n\t-- \"Some Text...\" is printed twice\n\t```\n\n\t@param ... any\n\t@ignore\n]=]\nfunction ScriptSignal:Fire(...: any)\n\tlocal node: ScriptConnectionNode? = self._head\n\twhile node ~= nil do\n\t\tif node._connection ~= nil then\n\t\t\tif FreeThread == nil then\n\t\t\t\ttask.spawn(CreateFreeThread)\n\t\t\tend\n\n\t\t\ttask.spawn(\n\t\t\t\tFreeThread :: thread,\n\t\t\t\tnode._handler, ...\n\t\t\t)\n\t\tend\n\n\t\tnode = node._next\n\tend\nend\n\n--[=[\n\tDisconnects all connections from a ScriptSignal object without making it unusable.\n\n\t```lua\n\tlocal connection = ScriptSignal:Connect(function() end)\n\n\tconnection.Connected -> true\n\tScriptSignal:DisconnectAll()\n\tconnection.Connected -> false\n\t```\n\n\t@ignore\n]=]\nfunction ScriptSignal:DisconnectAll()\n\tlocal node: ScriptConnectionNode? = self._head\n\twhile node ~= nil do\n\t\tlocal _connection = node._connection\n\n\t\tif _connection ~= nil then\n\t\t\t_connection.Connected = false\n\t\t\t_connection._node = nil\n\t\t\tnode._connection = nil\n\t\tend\n\n\t\tnode = node._next\n\tend\n\n\tself._head = nil\nend\n\n--[=[\n\tDestroys a ScriptSignal object, disconnecting all connections and making it unusable.\n\n\t```lua\n\tScriptSignal:Destroy()\n\n\tlocal connection = ScriptSignal:Connect(function() end)\n\tconnection.Connected -> false\n\t```\n\n\t@ignore\n]=]\nfunction ScriptSignal:Destroy()\n\tif self._active ~= true then\n\t\treturn\n\tend\n\n\tself:DisconnectAll()\n\tself._active = false\nend\n\n--[=[\n\tDisconnects a connection, any `:Fire` calls from now on will not\n\tinvoke this connection's handler.\n\n\t```lua\n\tlocal connection = ScriptSignal:Connect(function() end)\n\n\tconnection.Connected -> true\n\tconnection:Disconnect()\n\tconnection.Connected -> false\n\t```\n\n\t@ignore\n]=]\nfunction ScriptConnection:Disconnect()\n\tif self.Connected ~= true then\n\t\treturn\n\tend\n\n\tself.Connected = false\n\n\tlocal _node: ScriptConnectionNode = self._node\n\tlocal _prev = _node._prev\n\tlocal _next = _node._next\n\n\tif _next ~= nil then\n\t\t_next._prev = _prev\n\tend\n\n\tif _prev ~= nil then\n\t\t_prev._next = _next\n\telse\n\t\t-- _node == _signal._head\n\n\t\t_node._signal._head = _next\n\tend\n\n\t_node._connection = nil\n\tself._node = nil\nend\n\n-- Compatibility methods for TopbarPlus\nScriptConnection.destroy = ScriptConnection.Disconnect\nScriptConnection.Destroy = ScriptConnection.Disconnect\nScriptConnection.disconnect = ScriptConnection.Disconnect\nScriptSignal.destroy = ScriptSignal.Destroy\nScriptSignal.Disconnect = ScriptSignal.Destroy\nScriptSignal.disconnect = ScriptSignal.Destroy\n\nScriptSignal.connect = ScriptSignal.Connect\nScriptSignal.wait = ScriptSignal.Wait\nScriptSignal.fire = ScriptSignal.Fire\n\nreturn ScriptSignal"
Signal.Parent = Icon

local Maid = Instance.new("ModuleScript")
Maid.Name = "Maid"
Maid.Source = "-- Maid\n-- Author: Quenty\n-- Source: https://github.com/Quenty/NevermoreEngine/blob/8ef4242a880c645b2f82a706e8074e74f23aab06/Modules/Shared/Events/Maid.lua\n-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)\n\n\n---\tManages the cleaning of events and other things.\n-- Useful for encapsulating state and make deconstructors easy\n-- @classmod Maid\n-- @see Signal\n\nlocal Maid = {}\nMaid.ClassName = \"Maid\"\n\n--- Returns a new Maid object\n-- @constructor Maid.new()\n-- @treturn Maid\nfunction Maid.new()\n\treturn setmetatable({\n\t\t_tasks = {}\n\t}, Maid)\nend\n\nfunction Maid.isMaid(value)\n\treturn type(value) == \"table\" and value.ClassName == \"Maid\"\nend\n\n--- Returns Maid[key] if not part of Maid metatable\n-- @return Maid[key] value\nfunction Maid:__index(index)\n\tif Maid[index] then\n\t\treturn Maid[index]\n\telse\n\t\treturn self._tasks[index]\n\tend\nend\n\n--- Add a task to clean up. Tasks given to a maid will be cleaned when\n--  maid[index] is set to a different value.\n-- @usage\n-- Maid[key] = (function)         Adds a task to perform\n-- Maid[key] = (event connection) Manages an event connection\n-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.\n-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method\n-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,\n--                                it is destroyed.\nfunction Maid:__newindex(index, newTask)\n\tif Maid[index] ~= nil then\n\t\terror((\"'%s' is reserved\"):format(tostring(index)), 2)\n\tend\n\n\tlocal tasks = self._tasks\n\tlocal oldTask = tasks[index]\n\n\tif oldTask == newTask then\n\t\treturn\n\tend\n\n\ttasks[index] = newTask\n\n\tif oldTask then\n\t\tif type(oldTask) == \"function\" then\n\t\t\toldTask()\n\t\telseif typeof(oldTask) == \"RBXScriptConnection\" then\n\t\t\toldTask:Disconnect()\n\t\telseif oldTask.Destroy then\n\t\t\toldTask:Destroy()\n\t\telseif oldTask.destroy then\n\t\t\toldTask:destroy()\n\t\tend\n\tend\nend\n\n--- Same as indexing, but uses an incremented number as a key.\n-- @param task An item to clean\n-- @treturn number taskId\nfunction Maid:giveTask(task)\n\tif not task then\n\t\terror(\"Task cannot be false or nil\", 2)\n\tend\n\n\tlocal taskId = #self._tasks+1\n\tself[taskId] = task\n\n\tif type(task) == \"table\" and (not (task.Destroy or task.destroy)) then\n\t\twarn(\"[Maid.GiveTask] - Gave table task without .Destroy\\n\\n\" .. debug.traceback())\n\tend\n\n\treturn taskId\nend\n\n--[[ I wont' be using promises for TopbarPlus so we can ignore this method\nfunction Maid:givePromise(promise)\n\tif (promise:getStatus() ~= Promise.Status.Started) then\n\t\treturn promise\n\tend\n\n\tlocal newPromise = Promise.resolve(promise)\n\tlocal id = self:giveTask(newPromise)\n\n\t-- Ensure GC\n\tnewPromise:finally(function()\n\t\tself[id] = nil\n\tend)\n\n\treturn newPromise, id\nend--]]\n\nfunction Maid:give(taskOrPromise)\n\tlocal taskId\n\tif type(taskOrPromise) == \"table\" and taskOrPromise.isAPromise then\n\t\t_, taskId = self:givePromise(taskOrPromise)\n\telse\n\t\ttaskId = self:giveTask(taskOrPromise)\n\tend\n\treturn taskOrPromise, taskId\nend\n\n--- Cleans up all tasks.\n-- @alias Destroy\nfunction Maid:doCleaning()\n\tlocal tasks = self._tasks\n\n\t-- Disconnect all events first as we know this is safe\n\tfor index, task in pairs(tasks) do\n\t\tif typeof(task) == \"RBXScriptConnection\" then\n\t\t\ttasks[index] = nil\n\t\t\ttask:Disconnect()\n\t\tend\n\tend\n\n\t-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid\n\tlocal index, task = next(tasks)\n\twhile task ~= nil do\n\t\ttasks[index] = nil\n\t\tif type(task) == \"function\" then\n\t\t\ttask()\n\t\telseif typeof(task) == \"RBXScriptConnection\" then\n\t\t\ttask:Disconnect()\n\t\telseif task.Destroy then\n\t\t\ttask:Destroy()\n\t\telseif task.destroy then\n\t\t\ttask:destroy()\n\t\tend\n\t\tindex, task = next(tasks)\n\tend\nend\n\n--- Alias for DoCleaning()\n-- @function Destroy\nMaid.destroy = Maid.doCleaning\nMaid.clean = Maid.doCleaning\n\nreturn Maid"
Maid.Parent = Icon

local IconController = Instance.new("ModuleScript")
IconController.Name = "IconController"
IconController.Source = "--[[ icon_controller:header\n## Functions\n\n#### setGameTheme\n```lua\nIconController.setGameTheme(theme)\n```\nSets the default theme which is applied to all existing and future icons.\n\n----\n#### setDisplayOrder\n```lua\nIconController.setDisplayOrder(number)\n```\nChanges the DisplayOrder of the TopbarPlus ScreenGui to the given value.\n\n----\n#### setTopbarEnabled\n```lua\nIconController.setTopbarEnabled(bool)\n```\nWhen set to ``false``, hides all icons created with TopbarPlus. This can also be achieved by calling ``starterGui:SetCore(\"TopbarEnabled\", false)``.\n\n----\n#### setGap\n```lua\nIconController.setGap(integer, alignment)\n```\nDefines the offset width (i.e. gap) between each icon for the given alignment, ``left``, ``mid``, ``right``, or all alignments if not specified. \n\n----\n#### setLeftOffset\n```lua\nIconController.setLeftOffset(integer)\n```\nDefines the offset from the left side of the screen to the nearest left-set icon. \n\n----\n#### setRightOffset\n```lua\nIconController.setRightOffset(integer)\n```\nDefines the offset from the right side of the screen to the nearest right-set icon. \n\n----\n#### updateTopbar\n```lua\nIconController.updateTopbar()\n```\nDetermines how icons should be positioned on the topbar and moves them accordingly.  \n\n----\n#### clearIconOnSpawn\n```lua\nIconController.clearIconOnSpawn(icon)\n```\nCalls destroy on the given icon when the player respawns. This is useful for scenarious where you wish to cleanup icons that are constructed within a Gui with ``ResetOnSpawn`` set to ``true``. For example:\n\n```lua\n-- Place at the bottom of your icon creator localscript\nlocal icons = IconController.getIcons()\nfor _, icon in pairs(icons) do\n\tIconController.clearIconOnSpawn(icon)\nend\n```\n\n----\n#### getIcons\n```lua\nlocal arrayOfIcons = IconController.getIcons()\n```\nReturns all icons as an array.\n\n----\n#### getIcon\n```lua\nlocal icon = IconController.getIcon(name)\n```\nReturns the icon with the given name (or ``false`` if not found). If multiple icons have the same name, then one will be returned randomly.\n\n----\n#### disableHealthbar\n```lua\nIconController.disableHealthbar(bool)\n```\nHides the fake healthbar (if currently visible) and prevents it becoming visible again (which normally occurs when the player takes damage).\n\n----\n\n\n\n## Properties\n#### mimicCoreGui\n```lua\nlocal bool = IconController.mimicCoreGui --[default: 'true']\n```\nSet to ``false`` to have the topbar persist even when ``game:GetService(\"StarterGui\"):SetCore(\"TopbarEnabled\", false)`` is called.\n\n----\n#### controllerModeEnabled\n{read-only}\n```lua\nlocal bool = IconController.controllerModeEnabled\n```\n\n----\n#### leftGap\n{read-only}\n```lua\nlocal gapNumber = IconController.leftGap --[default: '12']\n```\n\n----\n#### midGap\n{read-only}\n```lua\nlocal gapNumber = IconController.midGap --[default: '12']\n```\n\n----\n#### rightGap\n{read-only}\n```lua\nlocal gapNumber = IconController.rightGap --[default: '12']\n```\n\n----\n#### leftOffset\n{read-only}\n```lua\nlocal offset = IconController.leftGap --[default: '0']\n```\n\n----\n#### rightOffset\n{read-only}\n```lua\nlocal offset = IconController.rightGap --[default: '0']\n```\n--]]\n\n\n\n-- LOCAL\nlocal starterGui = game:GetService(\"StarterGui\")\nlocal guiService = game:GetService(\"GuiService\")\nlocal hapticService = game:GetService(\"HapticService\")\nlocal runService = game:GetService(\"RunService\")\nlocal userInputService = game:GetService(\"UserInputService\")\nlocal tweenService = game:GetService(\"TweenService\")\nlocal players = game:GetService(\"Players\")\nlocal voiceChatService = game:GetService(\"VoiceChatService\")\nlocal localPlayer = players.LocalPlayer\nlocal IconController = {}\nlocal replicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Signal = require(script.Parent.Signal)\nlocal TopbarPlusGui = require(script.Parent.TopbarPlusGui)\nlocal topbarIcons = {}\nlocal fakeChatName = \"_FakeChat\"\nlocal forceTopbarDisabled = false\nlocal menuOpen\nlocal topbarUpdating = false\nlocal cameraConnection\nlocal controllerMenuOverride\nlocal isStudio = runService:IsStudio()\nlocal isVoiceChatEnabled = false\nlocal STUPID_CONTROLLER_OFFSET = 32\n\n\n\n-- LOCAL FUNCTIONS\nlocal function checkTopbarEnabled()\n\tlocal success, bool = xpcall(function()\n\t\treturn starterGui:GetCore(\"TopbarEnabled\")\n\tend,function(err)\n\t\t--has not been registered yet, but default is that is enabled\n\t\treturn true\t\n\tend)\n\treturn (success and bool)\nend\n\nlocal function checkTopbarEnabledAccountingForMimic()\n\tlocal topbarEnabledAccountingForMimic = (checkTopbarEnabled() or not IconController.mimicCoreGui)\n\treturn topbarEnabledAccountingForMimic\nend\n\n-- Add icons to an overflow if they overlap the screen bounds or other icons\nlocal function bindCamera()\n\tif not workspace.CurrentCamera then return end\n\tif cameraConnection and cameraConnection.Connected then\n\t\tcameraConnection:Disconnect()\n\tend\n\tcameraConnection = workspace.CurrentCamera:GetPropertyChangedSignal(\"ViewportSize\"):Connect(IconController.updateTopbar)\nend\n\n-- OFFSET HANDLERS\nlocal alignmentDetails = {}\nalignmentDetails[\"left\"] = {\n\tstartScale = 0,\n\tgetOffset = function()\n\t\tlocal offset = 48 + IconController.leftOffset\n\t\tif checkTopbarEnabled() then\n\t\t\tlocal chatEnabled = starterGui:GetCoreGuiEnabled(\"Chat\")\n\t\t\tif chatEnabled then\n\t\t\t\toffset += 12 + 32\n\t\t\tend\n\t\t\tif isVoiceChatEnabled and not isStudio then\n\t\t\t\tif chatEnabled then\n\t\t\t\t\toffset += 67\n\t\t\t\telse\n\t\t\t\t\toffset += 43\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn offset\n\tend,\n\tgetStartOffset = function()\n\t\tlocal alignmentGap = IconController[\"leftGap\"]\n\t\tlocal startOffset = alignmentDetails.left.getOffset() + alignmentGap\n\t\treturn startOffset\n\tend,\n\trecords = {}\n}\nalignmentDetails[\"mid\"] = {\n\tstartScale = 0.5,\n\tgetOffset = function()\n\t\treturn 0\n\tend,\n\tgetStartOffset = function(totalIconX) \n\t\tlocal alignmentGap = IconController[\"midGap\"]\n\t\treturn -totalIconX/2 + (alignmentGap/2)\n\tend,\n\trecords = {}\n}\nalignmentDetails[\"right\"] = {\n\tstartScale = 1,\n\tgetOffset = function()\n\t\tlocal offset = IconController.rightOffset\n\t\tif checkTopbarEnabled() and (starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList) or starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Backpack) or starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu)) then\n\t\t\toffset += 48\n\t\tend\n\t\treturn offset\n\tend,\n\tgetStartOffset = function(totalIconX)\n\t\tlocal startOffset = -totalIconX - alignmentDetails.right.getOffset()\n\t\treturn startOffset\n\tend,\n\trecords = {}\n\t--reverseSort = true\n}\n\n\n\n-- PROPERTIES\nIconController.topbarEnabled = true\nIconController.controllerModeEnabled = false\nIconController.previousTopbarEnabled = checkTopbarEnabled()\nIconController.leftGap = 12\nIconController.midGap = 12\nIconController.rightGap = 12\nIconController.leftOffset = 0\nIconController.rightOffset = 0\nIconController.mimicCoreGui = true\nIconController.healthbarDisabled = false\n\n\n\n-- EVENTS\nIconController.iconAdded = Signal.new()\nIconController.iconRemoved = Signal.new()\nIconController.controllerModeStarted = Signal.new()\nIconController.controllerModeEnded = Signal.new()\nIconController.healthbarDisabledSignal = Signal.new()\n\n\n\n-- CONNECTIONS\nlocal iconCreationCount = 0\nIconController.iconAdded:Connect(function(icon)\n\ttopbarIcons[icon] = true\n\tif IconController.gameTheme then\n\t\ticon:setTheme(IconController.gameTheme)\n\tend\n\ticon.updated:Connect(function()\n\t\tIconController.updateTopbar()\n\tend)\n\t-- When this icon is selected, deselect other icons if necessary\n\ticon.selected:Connect(function()\n\t\tlocal allIcons = IconController.getIcons()\n\t\tfor _, otherIcon in pairs(allIcons) do\n\t\t\tif icon.deselectWhenOtherIconSelected and otherIcon ~= icon and otherIcon.deselectWhenOtherIconSelected and otherIcon:getToggleState() == \"selected\" then\n\t\t\t\totherIcon:deselect(icon)\n\t\t\tend\n\t\tend\n\tend)\n\t-- Order by creation if no order specified\n\ticonCreationCount = iconCreationCount + 1\n\ticon:setOrder(iconCreationCount)\n\t-- Apply controller view if enabled\n\tif IconController.controllerModeEnabled then\n\t\tIconController._enableControllerModeForIcon(icon, true)\n\tend\n\tIconController:_updateSelectionGroup()\n\tIconController.updateTopbar()\nend)\n\nIconController.iconRemoved:Connect(function(icon)\n\ttopbarIcons[icon] = nil\n\ticon:setEnabled(false)\n\ticon:deselect()\n\ticon.updated:Fire()\n\tIconController:_updateSelectionGroup()\nend)\n\nworkspace:GetPropertyChangedSignal(\"CurrentCamera\"):Connect(bindCamera)\n\n\n-- METHODS\nfunction IconController.setGameTheme(theme)\n\tIconController.gameTheme = theme\n\tlocal icons = IconController.getIcons()\n\tfor _, icon in pairs(icons) do\n\t\ticon:setTheme(theme)\n\tend\nend\n\nfunction IconController.setDisplayOrder(value)\n\tvalue = tonumber(value) or TopbarPlusGui.DisplayOrder\n\tTopbarPlusGui.DisplayOrder = value\nend\nIconController.setDisplayOrder(10)\n\nfunction IconController.getIcons()\n\tlocal allIcons = {}\n\tfor otherIcon, _ in pairs(topbarIcons) do\n\t\ttable.insert(allIcons, otherIcon)\n\tend\n\treturn allIcons\nend\n\nfunction IconController.getIcon(name)\n\tfor otherIcon, _ in pairs(topbarIcons) do\n\t\tif otherIcon.name == name then\n\t\t\treturn otherIcon\n\t\tend\n\tend\n\treturn false\nend\n\nfunction IconController.disableHealthbar(bool)\n\tlocal finalBool = (bool == nil or bool)\n\tIconController.healthbarDisabled = finalBool\n\tIconController.healthbarDisabledSignal:Fire(finalBool)\nend\n\nfunction IconController.canShowIconOnTopbar(icon)\n\tif (icon.enabled == true or icon.accountForWhenDisabled) and icon.presentOnTopbar then\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction IconController.getMenuOffset(icon)\n\tlocal alignment = icon:get(\"alignment\")\n\tlocal alignmentGap = IconController[alignment..\"Gap\"]\n\tlocal iconSize = icon:get(\"iconSize\") or UDim2.new(0, 32, 0, 32)\n\tlocal sizeX = iconSize.X.Offset\n\tlocal iconWidthAndGap = (sizeX + alignmentGap)\n\tlocal extendLeft = 0\n\tlocal extendRight = 0\n\tlocal additionalRight = 0\n\tif icon.menuOpen then\n\t\tlocal menuSize = icon:get(\"menuSize\")\n\t\tlocal menuSizeXOffset = menuSize.X.Offset\n\t\tlocal direction = icon:_getMenuDirection()\n\t\tif direction == \"right\" then\n\t\t\textendRight += menuSizeXOffset + alignmentGap/6--2\n\t\telseif direction == \"left\" then\n\t\t\textendLeft = menuSizeXOffset + 4\n\t\t\textendRight += alignmentGap/3--4\n\t\t\tadditionalRight = menuSizeXOffset\n\t\tend\n\tend\n\treturn extendLeft, extendRight, additionalRight\nend\n\n-- This is responsible for positioning the topbar icons\nlocal requestedTopbarUpdate = false\nfunction IconController.updateTopbar()\n\tlocal function getIncrement(otherIcon, alignment)\n\t\t--local container = otherIcon.instances.iconContainer\n\t\t--local sizeX = container.Size.X.Offset\n\t\tlocal iconSize = otherIcon:get(\"iconSize\", otherIcon:getIconState()) or UDim2.new(0, 32, 0, 32)\n\t\tlocal sizeX = iconSize.X.Offset\n\t\tlocal alignmentGap = IconController[alignment..\"Gap\"]\n\t\tlocal iconWidthAndGap = (sizeX + alignmentGap)\n\t\tlocal increment = iconWidthAndGap\n\t\tlocal preOffset = 0\n\t\tif otherIcon._parentIcon == nil then\n\t\t\tlocal extendLeft, extendRight, additionalRight = IconController.getMenuOffset(otherIcon)\n\t\t\tpreOffset += extendLeft\n\t\t\tincrement += extendRight + additionalRight\n\t\tend\n\t\treturn increment, preOffset\n\tend\n\tif topbarUpdating then -- This prevents the topbar updating and shifting icons more than it needs to\n\t\trequestedTopbarUpdate = true\n\t\treturn false\n\tend\n\tcoroutine.wrap(function()\n\t\ttopbarUpdating = true\n\t\trunService.Heartbeat:Wait()\n\t\ttopbarUpdating = false\n\t\t\n\t\tfor alignment, alignmentInfo in pairs(alignmentDetails) do\n\t\t\talignmentInfo.records = {}\n\t\tend\n\n\t\tfor otherIcon, _ in pairs(topbarIcons) do\n\t\t\tif IconController.canShowIconOnTopbar(otherIcon) then\n\t\t\t\tlocal alignment = otherIcon:get(\"alignment\")\n\t\t\t\ttable.insert(alignmentDetails[alignment].records, otherIcon)\n\t\t\tend\n\t\tend\n\t\tlocal viewportSize = workspace.CurrentCamera.ViewportSize\n\t\tfor alignment, alignmentInfo in pairs(alignmentDetails) do\n\t\t\tlocal records = alignmentInfo.records\n\t\t\tif #records > 1 then\n\t\t\t\tif alignmentInfo.reverseSort then\n\t\t\t\t\ttable.sort(records, function(a,b) return a:get(\"order\") > b:get(\"order\") end)\n\t\t\t\telse\n\t\t\t\t\ttable.sort(records, function(a,b) return a:get(\"order\") < b:get(\"order\") end)\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal totalIconX = 0\n\t\t\tfor i, otherIcon in pairs(records) do\n\t\t\t\tlocal increment = getIncrement(otherIcon, alignment)\n\t\t\t\ttotalIconX = totalIconX + increment\n\t\t\tend\n\t\t\tlocal offsetX = alignmentInfo.getStartOffset(totalIconX, alignment)\n\t\t\tlocal preOffsetX = offsetX\n\t\t\tlocal containerX = TopbarPlusGui.TopbarContainer.AbsoluteSize.X\n\t\t\tfor i, otherIcon in pairs(records) do\n\t\t\t\tlocal increment, preOffset = getIncrement(otherIcon, alignment)\n\t\t\t\tlocal newAbsoluteX = alignmentInfo.startScale*containerX + preOffsetX+preOffset\n\t\t\t\tpreOffsetX = preOffsetX + increment\n\t\t\tend\n\t\t\tfor i, otherIcon in pairs(records) do\n\t\t\t\tlocal container = otherIcon.instances.iconContainer\n\t\t\t\tlocal increment, preOffset = getIncrement(otherIcon, alignment)\n\t\t\t\tlocal topPadding = otherIcon.topPadding\n\t\t\t\tlocal newPositon = UDim2.new(alignmentInfo.startScale, offsetX+preOffset, topPadding.Scale, topPadding.Offset)\n\t\t\t\tlocal isAnOverflowIcon = string.match(otherIcon.name, \"_overflowIcon-\")\n\t\t\t\tlocal repositionInfo = otherIcon:get(\"repositionInfo\")\n\t\t\t\tif repositionInfo then\n\t\t\t\t\ttweenService:Create(container, repositionInfo, {Position = newPositon}):Play()\n\t\t\t\telse\n\t\t\t\t\tcontainer.Position = newPositon\n\t\t\t\tend\n\t\t\t\toffsetX = offsetX + increment\n\t\t\t\totherIcon.targetPosition = UDim2.new(0, (newPositon.X.Scale*viewportSize.X) + newPositon.X.Offset, 0, (newPositon.Y.Scale*viewportSize.Y) + newPositon.Y.Offset)\n\t\t\tend\n\t\tend\n\n\t\t-- OVERFLOW HANDLER\n\t\t--------\n\t\tlocal START_LEEWAY = 10 -- The additional offset where the end icon will be converted to ... without an apparant change in position\n\t\tlocal function getBoundaryX(iconToCheck, side, gap)\n\t\t\tlocal additionalGap = gap or 0\n\t\t\tlocal currentSize = iconToCheck:get(\"iconSize\", iconToCheck:getIconState())\n\t\t\tlocal sizeX = currentSize.X.Offset\n\t\t\tlocal extendLeft, extendRight = IconController.getMenuOffset(iconToCheck)\n\t\t\tlocal boundaryXOffset = (side == \"left\" and (-additionalGap-extendLeft)) or (side == \"right\" and sizeX+additionalGap+extendRight)\n\t\t\tlocal boundaryX = iconToCheck.targetPosition.X.Offset + boundaryXOffset\n\t\t\treturn boundaryX\n\t\tend\n\t\tlocal function getSizeX(iconToCheck, usePrevious)\n\t\t\tlocal currentSize, previousSize = iconToCheck:get(\"iconSize\", iconToCheck:getIconState(), \"beforeDropdown\")\n\t\t\tlocal hoveringSize = iconToCheck:get(\"iconSize\", \"hovering\")\n\t\t\tif iconToCheck.wasHoveringBeforeOverflow and previousSize and hoveringSize and hoveringSize.X.Offset > previousSize.X.Offset then\n\t\t\t\t-- This prevents hovering icons flicking back and forth, demonstrated at thread/1017485/191.\n\t\t\t\tpreviousSize = hoveringSize\n\t\t\tend\n\t\t\tlocal newSize = (usePrevious and previousSize) or currentSize\n\t\t\tlocal extendLeft, extendRight = IconController.getMenuOffset(iconToCheck)\n\t\t\tlocal sizeX = newSize.X.Offset + extendLeft + extendRight\n\t\t\treturn sizeX\n\t\tend\n\n\t\tfor alignment, alignmentInfo in pairs(alignmentDetails) do\n\t\t\tlocal overflowIcon = alignmentInfo.overflowIcon\n\t\t\tif overflowIcon then\n\t\t\t\tlocal alignmentGap = IconController[alignment..\"Gap\"]\n\t\t\t\tlocal oppositeAlignment = (alignment == \"left\" and \"right\") or \"left\"\n\t\t\t\tlocal oppositeAlignmentInfo = alignmentDetails[oppositeAlignment]\n\t\t\t\tlocal oppositeOverflowIcon = IconController.getIcon(\"_overflowIcon-\"..oppositeAlignment)\n\t\t\t\t\n\t\t\t\t-- This determines whether any icons (from opposite or mid alignment) are overlapping with this alignment\n\t\t\t\tlocal overflowBoundaryX = getBoundaryX(overflowIcon, alignment)\n\t\t\t\tif overflowIcon.enabled then\n\t\t\t\t\toverflowBoundaryX = getBoundaryX(overflowIcon, oppositeAlignment, alignmentGap)\n\t\t\t\tend\n\t\t\t\tlocal function doesExceed(givenBoundaryX)\n\t\t\t\t\tlocal exceeds = (alignment == \"left\" and givenBoundaryX < overflowBoundaryX) or (alignment == \"right\" and givenBoundaryX > overflowBoundaryX)\n\t\t\t\t\treturn exceeds\n\t\t\t\tend\n\t\t\t\tlocal alignmentOffset = oppositeAlignmentInfo.getOffset()\n\t\t\t\tif not overflowIcon.enabled then\n\t\t\t\t\talignmentOffset += START_LEEWAY\n\t\t\t\tend\n\t\t\t\tlocal alignmentBorderX = (alignment == \"left\" and viewportSize.X - alignmentOffset) or (alignment == \"right\" and alignmentOffset)\n\t\t\t\tlocal closestBoundaryX = alignmentBorderX\n\t\t\t\tlocal exceededCriticalBoundary = doesExceed(closestBoundaryX)\n\t\t\t\tlocal function checkBoundaryExceeded(recordToCheck)\n\t\t\t\t\tlocal totalIcons = #recordToCheck\n\t\t\t\t\tfor i = 1, totalIcons do\n\t\t\t\t\t\tlocal endIcon = recordToCheck[totalIcons+1 - i]\n\t\t\t\t\t\tif IconController.canShowIconOnTopbar(endIcon) then\n\t\t\t\t\t\t\tlocal isAnOverflowIcon = string.match(endIcon.name, \"_overflowIcon-\")\n\t\t\t\t\t\t\tif isAnOverflowIcon and totalIcons ~= 1 then\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telseif isAnOverflowIcon and not endIcon.enabled then\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tlocal additionalMyX = 0\n\t\t\t\t\t\t\tif not overflowIcon.enabled then\n\t\t\t\t\t\t\t\tadditionalMyX = START_LEEWAY\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tlocal myBoundaryX = getBoundaryX(endIcon, alignment, additionalMyX)\n\t\t\t\t\t\t\tlocal isNowClosest = (alignment == \"left\" and myBoundaryX < closestBoundaryX) or (alignment == \"right\" and myBoundaryX > closestBoundaryX)\n\t\t\t\t\t\t\tif isNowClosest then\n\t\t\t\t\t\t\t\tclosestBoundaryX = myBoundaryX\n\t\t\t\t\t\t\t\tif doesExceed(myBoundaryX) then\n\t\t\t\t\t\t\t\t\texceededCriticalBoundary = true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tcheckBoundaryExceeded(alignmentDetails[oppositeAlignment].records)\n\t\t\t\tcheckBoundaryExceeded(alignmentDetails.mid.records)\n\n\t\t\t\t-- This determines which icons to give to the overflow if an overlap is present\n\t\t\t\tif exceededCriticalBoundary then\n\t\t\t\t\tlocal recordToCheck = alignmentInfo.records\n\t\t\t\t\tlocal totalIcons = #recordToCheck\n\t\t\t\t\tfor i = 1, totalIcons do\n\t\t\t\t\t\tlocal endIcon = (alignment == \"left\" and recordToCheck[totalIcons+1 - i]) or (alignment == \"right\" and recordToCheck[i])\n\t\t\t\t\t\tif endIcon ~= overflowIcon and IconController.canShowIconOnTopbar(endIcon) then\n\t\t\t\t\t\t\tlocal additionalGap = alignmentGap\n\t\t\t\t\t\t\tlocal overflowIconSizeX = overflowIcon:get(\"iconSize\", overflowIcon:getIconState()).X.Offset\n\t\t\t\t\t\t\tif overflowIcon.enabled then\n\t\t\t\t\t\t\t\tadditionalGap += alignmentGap + overflowIconSizeX\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tlocal myBoundaryXPlusGap = getBoundaryX(endIcon, oppositeAlignment, additionalGap)\n\t\t\t\t\t\t\tlocal exceeds = (alignment == \"left\" and myBoundaryXPlusGap >= closestBoundaryX) or (alignment == \"right\" and myBoundaryXPlusGap <= closestBoundaryX)\n\t\t\t\t\t\t\tif exceeds then\n\t\t\t\t\t\t\t\tif not overflowIcon.enabled then\n\t\t\t\t\t\t\t\t\tlocal overflowContainer = overflowIcon.instances.iconContainer\n\t\t\t\t\t\t\t\t\tlocal yPos = overflowContainer.Position.Y\n\t\t\t\t\t\t\t\t\tlocal appearXAdditional = (alignment == \"left\" and -overflowContainer.Size.X.Offset) or 0\n\t\t\t\t\t\t\t\t\tlocal appearX = getBoundaryX(endIcon, oppositeAlignment, appearXAdditional)\n\t\t\t\t\t\t\t\t\toverflowContainer.Position = UDim2.new(0, appearX, yPos.Scale, yPos.Offset)\n\t\t\t\t\t\t\t\t\toverflowIcon:setEnabled(true)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tif #endIcon.dropdownIcons > 0 then\n\t\t\t\t\t\t\t\t\tendIcon._overflowConvertedToMenu = true\n\t\t\t\t\t\t\t\t\tlocal wasSelected = endIcon.isSelected\n\t\t\t\t\t\t\t\t\tendIcon:deselect()\n\t\t\t\t\t\t\t\t\tlocal iconsToConvert = {}\n\t\t\t\t\t\t\t\t\tfor _, dIcon in pairs(endIcon.dropdownIcons) do\n\t\t\t\t\t\t\t\t\t\ttable.insert(iconsToConvert, dIcon)\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tfor _, dIcon in pairs(endIcon.dropdownIcons) do\n\t\t\t\t\t\t\t\t\t\tdIcon:leave()\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\tendIcon:setMenu(iconsToConvert)\n\t\t\t\t\t\t\t\t\tif wasSelected and overflowIcon.isSelected then\n\t\t\t\t\t\t\t\t\t\tendIcon:select()\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tif endIcon.hovering then\n\t\t\t\t\t\t\t\t\tendIcon.wasHoveringBeforeOverflow = true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tendIcon:join(overflowIcon, \"dropdown\")\n\t\t\t\t\t\t\t\tif #endIcon.menuIcons > 0 and endIcon.menuOpen then\n\t\t\t\t\t\t\t\t\tendIcon:deselect()\n\t\t\t\t\t\t\t\t\tendIcon:select()\n\t\t\t\t\t\t\t\t\toverflowIcon:select()\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\t\n\t\t\t\t\t-- This checks to see if the lowest/highest (depending on left/right) ordered overlapping icon is no longer overlapping, removes from the dropdown, and repeats if valid\n\t\t\t\t\tlocal winningOrder, winningOverlappedIcon\n\t\t\t\t\tlocal totalOverlappingIcons = #overflowIcon.dropdownIcons\n\t\t\t\t\tif not (oppositeOverflowIcon and oppositeOverflowIcon.enabled and #alignmentInfo.records == 1 and #oppositeAlignmentInfo.records ~= 1) then\n\t\t\t\t\t\tfor _, overlappedIcon in pairs(overflowIcon.dropdownIcons) do\n\t\t\t\t\t\t\tlocal iconOrder = overlappedIcon:get(\"order\")\n\t\t\t\t\t\t\tif winningOverlappedIcon == nil or (alignment == \"left\" and iconOrder < winningOrder) or (alignment == \"right\" and iconOrder > winningOrder) then\n\t\t\t\t\t\t\t\twinningOrder = iconOrder\n\t\t\t\t\t\t\t\twinningOverlappedIcon = overlappedIcon\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif winningOverlappedIcon then\n\t\t\t\t\t\tlocal sizeX = getSizeX(winningOverlappedIcon, true)\n\t\t\t\t\t\tlocal myForesightBoundaryX = getBoundaryX(overflowIcon, oppositeAlignment)\n\t\t\t\t\t\tif totalOverlappingIcons == 1 then\n\t\t\t\t\t\t\tmyForesightBoundaryX = getBoundaryX(overflowIcon, alignment, alignmentGap-START_LEEWAY)\n\t\t\t\t\t\tend\n\t\t\t\t\t\tlocal availableGap = math.abs(closestBoundaryX - myForesightBoundaryX) - (alignmentGap*2)\n\t\t\t\t\t\tlocal noLongerExeeds = (sizeX < availableGap)\n\t\t\t\t\t\tif noLongerExeeds then\n\t\t\t\t\t\t\tif #overflowIcon.dropdownIcons == 1 then\n\t\t\t\t\t\t\t\toverflowIcon:setEnabled(false)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tlocal overflowContainer = overflowIcon.instances.iconContainer\n\t\t\t\t\t\t\tlocal yPos = overflowContainer.Position.Y\n\t\t\t\t\t\t\toverflowContainer.Position = UDim2.new(0, myForesightBoundaryX, yPos.Scale, yPos.Offset)\n\t\t\t\t\t\t\twinningOverlappedIcon:leave()\n\t\t\t\t\t\t\twinningOverlappedIcon.wasHoveringBeforeOverflow = nil\n\t\t\t\t\t\t\t--\n\t\t\t\t\t\t\tif winningOverlappedIcon._overflowConvertedToMenu then\n\t\t\t\t\t\t\t\twinningOverlappedIcon._overflowConvertedToMenu = nil\n\t\t\t\t\t\t\t\tlocal iconsToConvert = {}\n\t\t\t\t\t\t\t\tfor _, dIcon in pairs(winningOverlappedIcon.menuIcons) do\n\t\t\t\t\t\t\t\t\ttable.insert(iconsToConvert, dIcon)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tfor _, dIcon in pairs(winningOverlappedIcon.menuIcons) do\n\t\t\t\t\t\t\t\t\tdIcon:leave()\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\twinningOverlappedIcon:setDropdown(iconsToConvert)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t--\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t--------\n\t\tif requestedTopbarUpdate then\n\t\t\trequestedTopbarUpdate = false\n\t\t\tIconController.updateTopbar()\n\t\tend\n\t\treturn true\n\tend)()\nend\n\nfunction IconController.setTopbarEnabled(bool, forceBool)\n\tif forceBool == nil then\n\t\tforceBool = true\n\tend\n\tlocal indicator = TopbarPlusGui.Indicator\n\tif forceBool and not bool then\n\t\tforceTopbarDisabled = true\n\telseif forceBool and bool then\n\t\tforceTopbarDisabled = false\n\tend\n\tlocal topbarEnabledAccountingForMimic = checkTopbarEnabledAccountingForMimic()\n\tif IconController.controllerModeEnabled then\n\t\tif bool then\n\t\t\tif TopbarPlusGui.TopbarContainer.Visible or forceTopbarDisabled or menuOpen or not topbarEnabledAccountingForMimic then return end\n\t\t\tif forceBool then\n\t\t\t\tindicator.Visible = topbarEnabledAccountingForMimic\n\t\t\telse\n\t\t\t\tindicator.Active = false\n\t\t\t\tif controllerMenuOverride and controllerMenuOverride.Connected then\n\t\t\t\t\tcontrollerMenuOverride:Disconnect()\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif hapticService:IsVibrationSupported(Enum.UserInputType.Gamepad1) and hapticService:IsMotorSupported(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small) then\n\t\t\t\t\thapticService:SetMotor(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small,1)\n\t\t\t\t\tdelay(0.2,function()\n\t\t\t\t\t\tpcall(function()\n\t\t\t\t\t\t\thapticService:SetMotor(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small,0)\n\t\t\t\t\t\tend)\n\t\t\t\t\tend)\n\t\t\t\tend\n\t\t\t\tTopbarPlusGui.TopbarContainer.Visible = true\n\t\t\t\tTopbarPlusGui.TopbarContainer:TweenPosition(\n\t\t\t\t\tUDim2.new(0,0,0,5 + STUPID_CONTROLLER_OFFSET),\n\t\t\t\t\tEnum.EasingDirection.Out,\n\t\t\t\t\tEnum.EasingStyle.Quad,\n\t\t\t\t\t0.1,\n\t\t\t\t\ttrue\n\t\t\t\t)\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlocal selectIcon\n\t\t\t\tlocal targetOffset = 0\n\t\t\t\tIconController:_updateSelectionGroup()\n\t\t\t\trunService.Heartbeat:Wait()\n\t\t\t\tlocal indicatorSizeTrip = 50 --indicator.AbsoluteSize.Y * 2\n\t\t\t\tfor otherIcon, _ in pairs(topbarIcons) do\n\t\t\t\t\tif IconController.canShowIconOnTopbar(otherIcon) and (selectIcon == nil or otherIcon:get(\"order\") > selectIcon:get(\"order\")) then\n\t\t\t\t\t\tselectIcon = otherIcon\n\t\t\t\t\tend\n\t\t\t\t\tlocal container = otherIcon.instances.iconContainer\n\t\t\t\t\tlocal newTargetOffset = -27 + container.AbsoluteSize.Y + indicatorSizeTrip\n\t\t\t\t\tif newTargetOffset > targetOffset then\n\t\t\t\t\t\ttargetOffset = newTargetOffset\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif guiService:GetEmotesMenuOpen() then\n\t\t\t\t\tguiService:SetEmotesMenuOpen(false)\n\t\t\t\tend\n\t\t\t\tif guiService:GetInspectMenuEnabled() then\n\t\t\t\t\tguiService:CloseInspectMenu()\n\t\t\t\tend\n\t\t\t\tlocal newSelectedObject = IconController._previousSelectedObject or selectIcon.instances.iconButton\n\t\t\t\tIconController._setControllerSelectedObject(newSelectedObject)\n\t\t\t\tindicator.Image = \"rbxassetid://5278151071\"\n\t\t\t\tindicator:TweenPosition(\n\t\t\t\t\tUDim2.new(0.5,0,0,targetOffset + STUPID_CONTROLLER_OFFSET),\n\t\t\t\t\tEnum.EasingDirection.Out,\n\t\t\t\t\tEnum.EasingStyle.Quad,\n\t\t\t\t\t0.1,\n\t\t\t\t\ttrue\n\t\t\t\t)\n\t\t\tend\n\t\telse\n\t\t\tif forceBool then\n\t\t\t\tindicator.Visible = false\n\t\t\telseif topbarEnabledAccountingForMimic then\n\t\t\t\tindicator.Visible = true\n\t\t\t\tindicator.Active = true\n\t\t\t\tcontrollerMenuOverride = indicator.InputBegan:Connect(function(input)\n\t\t\t\t\tif input.UserInputType == Enum.UserInputType.MouseButton1 then\n\t\t\t\t\t\tIconController.setTopbarEnabled(true,false)\n\t\t\t\t\tend\n\t\t\t\tend)\n\t\t\telse\n\t\t\t\tindicator.Visible = false\n\t\t\tend\n\t\t\tif not TopbarPlusGui.TopbarContainer.Visible then return end\n\t\t\tguiService.AutoSelectGuiEnabled = true\n\t\t\tIconController:_updateSelectionGroup(true)\n\t\t\tTopbarPlusGui.TopbarContainer:TweenPosition(\n\t\t\t\tUDim2.new(0,0,0,-TopbarPlusGui.TopbarContainer.Size.Y.Offset + STUPID_CONTROLLER_OFFSET),\n\t\t\t\tEnum.EasingDirection.Out,\n\t\t\t\tEnum.EasingStyle.Quad,\n\t\t\t\t0.1,\n\t\t\t\ttrue,\n\t\t\t\tfunction()\n\t\t\t\t\tTopbarPlusGui.TopbarContainer.Visible = false\n\t\t\t\tend\n\t\t\t)\n\t\t\tindicator.Image = \"rbxassetid://5278151556\"\n\t\t\tindicator:TweenPosition(\n\t\t\t\tUDim2.new(0.5,0,0,5),\n\t\t\t\tEnum.EasingDirection.Out,\n\t\t\t\tEnum.EasingStyle.Quad,\n\t\t\t\t0.1,\n\t\t\t\ttrue\n\t\t\t)\n\t\tend\n\telse\n\t\tlocal topbarContainer = TopbarPlusGui.TopbarContainer\n\t\tif topbarEnabledAccountingForMimic then\n\t\t\ttopbarContainer.Visible = bool\n\t\telse\n\t\t\ttopbarContainer.Visible = false\n\t\tend\n\tend\nend\n\nfunction IconController.setGap(value, alignment)\n\tlocal newValue = tonumber(value) or 12\n\tlocal newAlignment = tostring(alignment):lower()\n\tif newAlignment == \"left\" or newAlignment == \"mid\" or newAlignment == \"right\" then\n\t\tIconController[newAlignment..\"Gap\"] = newValue\n\t\tIconController.updateTopbar()\n\t\treturn\n\tend\n\tIconController.leftGap = newValue\n\tIconController.midGap = newValue\n\tIconController.rightGap = newValue\n\tIconController.updateTopbar()\nend\n\nfunction IconController.setLeftOffset(value)\n\tIconController.leftOffset = tonumber(value) or 0\n\tIconController.updateTopbar()\nend\n\nfunction IconController.setRightOffset(value)\n\tIconController.rightOffset = tonumber(value) or 0\n\tIconController.updateTopbar()\nend\n\nlocal localPlayer = players.LocalPlayer\nlocal iconsToClearOnSpawn = {}\nlocalPlayer.CharacterAdded:Connect(function()\n\tfor _, icon in pairs(iconsToClearOnSpawn) do\n\t\ticon:destroy()\n\tend\n\ticonsToClearOnSpawn = {}\nend)\nfunction IconController.clearIconOnSpawn(icon)\n\tcoroutine.wrap(function()\n\t\tlocal char = localPlayer.Character or localPlayer.CharacterAdded:Wait()\n\t\ttable.insert(iconsToClearOnSpawn, icon)\n\tend)()\nend\n\n\n\n-- PRIVATE METHODS\nfunction IconController:_updateSelectionGroup(clearAll)\n\tif IconController._navigationEnabled then\n\t\tguiService:RemoveSelectionGroup(\"TopbarPlusIcons\")\n\tend\n\tif clearAll then\n\t\tguiService.CoreGuiNavigationEnabled = IconController._originalCoreGuiNavigationEnabled\n\t\tguiService.GuiNavigationEnabled = IconController._originalGuiNavigationEnabled\n\t\tIconController._navigationEnabled = nil\n\telseif IconController.controllerModeEnabled then\n\t\tlocal icons = IconController.getIcons()\n\t\tlocal iconContainers = {}\n\t\tfor i, otherIcon in pairs(icons) do\n\t\t\tlocal featureName = otherIcon.joinedFeatureName\n\t\t\tif not featureName or otherIcon._parentIcon[otherIcon.joinedFeatureName..\"Open\"] == true then\n\t\t\t\ttable.insert(iconContainers, otherIcon.instances.iconButton)\n\t\t\tend\n\t\tend\n\t\tguiService:AddSelectionTuple(\"TopbarPlusIcons\", table.unpack(iconContainers))\n\t\tif not IconController._navigationEnabled then\n\t\t\tIconController._originalCoreGuiNavigationEnabled = guiService.CoreGuiNavigationEnabled\n\t\t\tIconController._originalGuiNavigationEnabled = guiService.GuiNavigationEnabled\n\t\t\tguiService.CoreGuiNavigationEnabled = false\n\t\t\tguiService.GuiNavigationEnabled = true\n\t\t\tIconController._navigationEnabled = true\n\t\tend\n\tend\nend\n\nlocal function getScaleMultiplier()\n\tif guiService:IsTenFootInterface() then\n\t\treturn 3\n\telse\n\t\treturn 1.3\n\tend\nend\n\nfunction IconController._setControllerSelectedObject(object)\n\tlocal startId = (IconController._controllerSetCount and IconController._controllerSetCount + 1) or 0\n\tIconController._controllerSetCount = startId\n\tguiService.SelectedObject = object\n\tdelay(0.1, function() -- blame the roblox guiservice its a piece of doo doo\n\t\tlocal finalId = IconController._controllerSetCount\n\t\tif startId == finalId then\n\t\t\tguiService.SelectedObject = object\n\t\tend\n\tend)\nend\n\nfunction IconController._enableControllerMode(bool)\n\tlocal indicator = TopbarPlusGui.Indicator\n\tlocal controllerOptionIcon = IconController.getIcon(\"_TopbarControllerOption\")\n\tif IconController.controllerModeEnabled == bool then\n\t\treturn\n\tend\n\tIconController.controllerModeEnabled = bool\n\tif bool then\n\t\tTopbarPlusGui.TopbarContainer.Position = UDim2.new(0,0,0,5)\n\t\tTopbarPlusGui.TopbarContainer.Visible = false\n\t\tlocal scaleMultiplier = getScaleMultiplier()\n\t\tindicator.Position = UDim2.new(0.5,0,0,5)\n\t\tindicator.Size = UDim2.new(0, 18*scaleMultiplier, 0, 18*scaleMultiplier)\n\t\tindicator.Image = \"rbxassetid://5278151556\"\n\t\tindicator.Visible = checkTopbarEnabledAccountingForMimic()\n\t\tindicator.Position = UDim2.new(0.5,0,0,5)\n\t\tindicator.Active = true\n\t\tcontrollerMenuOverride = indicator.InputBegan:Connect(function(input)\n\t\t\tif input.UserInputType == Enum.UserInputType.MouseButton1 then\n\t\t\t\tIconController.setTopbarEnabled(true,false)\n\t\t\tend\n\t\tend)\n\telse\n\t\tTopbarPlusGui.TopbarContainer.Position = UDim2.new(0,0,0,0)\n\t\tTopbarPlusGui.TopbarContainer.Visible = checkTopbarEnabledAccountingForMimic()\n\t\tindicator.Visible = false\n\t\tIconController._setControllerSelectedObject(nil)\n\tend\n\tfor icon, _ in pairs(topbarIcons) do\n\t\tIconController._enableControllerModeForIcon(icon, bool)\n\tend\nend\n\nfunction IconController._enableControllerModeForIcon(icon, bool)\n\tlocal parentIcon = icon._parentIcon\n\tlocal featureName = icon.joinedFeatureName\n\tif parentIcon then\n\t\ticon:leave()\n\tend\n\tif bool then\n\t\tlocal scaleMultiplier = getScaleMultiplier()\n\t\tlocal currentSizeDeselected = icon:get(\"iconSize\", \"deselected\")\n\t\tlocal currentSizeSelected = icon:get(\"iconSize\", \"selected\")\n\t\tlocal currentSizeHovering = icon:getHovering(\"iconSize\")\n\t\ticon:set(\"iconSize\", UDim2.new(0, currentSizeDeselected.X.Offset*scaleMultiplier, 0, currentSizeDeselected.Y.Offset*scaleMultiplier), \"deselected\", \"controllerMode\")\n\t\ticon:set(\"iconSize\", UDim2.new(0, currentSizeSelected.X.Offset*scaleMultiplier, 0, currentSizeSelected.Y.Offset*scaleMultiplier), \"selected\", \"controllerMode\")\n\t\tif currentSizeHovering then\n\t\t\ticon:set(\"iconSize\", UDim2.new(0, currentSizeSelected.X.Offset*scaleMultiplier, 0, currentSizeSelected.Y.Offset*scaleMultiplier), \"hovering\", \"controllerMode\")\n\t\tend\n\t\ticon:set(\"alignment\", \"mid\", \"deselected\", \"controllerMode\")\n\t\ticon:set(\"alignment\", \"mid\", \"selected\", \"controllerMode\")\n\telse\n\t\tlocal states = {\"deselected\", \"selected\", \"hovering\"}\n\t\tfor _, iconState in pairs(states) do\n\t\t\tlocal _, previousAlignment = icon:get(\"alignment\", iconState, \"controllerMode\")\n\t\t\tif previousAlignment then\n\t\t\t\ticon:set(\"alignment\", previousAlignment, iconState)\n\t\t\tend\n\t\t\tlocal currentSize, previousSize = icon:get(\"iconSize\", iconState, \"controllerMode\")\n\t\t\tif previousSize then\n\t\t\t\ticon:set(\"iconSize\", previousSize, iconState)\n\t\t\tend\n\t\tend\n\tend\n\tif parentIcon then\n\t\ticon:join(parentIcon, featureName)\n\tend\nend\n\nlocal createdFakeHealthbarIcon = false\nfunction IconController.setupHealthbar()\n\n\tif createdFakeHealthbarIcon then\n\t\treturn\n\tend\n\tcreatedFakeHealthbarIcon = true\n\n\t-- Create a fake healthbar icon to mimic the core health gui\n\ttask.defer(function()\n\t\trunService.Heartbeat:Wait()\n\t\tlocal Icon = require(script.Parent)\n\n\t\tIcon.new()\n\t\t\t:setProperty(\"internalIcon\", true)\n\t\t\t:setName(\"_FakeHealthbar\")\n\t\t\t:setRight()\n\t\t\t:setOrder(-420)\n\t\t\t:setSize(80, 32)\n\t\t\t:lock()\n\t\t\t:set(\"iconBackgroundTransparency\", 1)\n\t\t\t:give(function(icon)\n\n\t\t\t\tlocal healthContainer = Instance.new(\"Frame\")\n\t\t\t\thealthContainer.Name = \"HealthContainer\"\n\t\t\t\thealthContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)\n\t\t\t\thealthContainer.BorderSizePixel = 0\n\t\t\t\thealthContainer.AnchorPoint = Vector2.new(0, 0.5)\n\t\t\t\thealthContainer.Position = UDim2.new(0, 0, 0.5, 0)\n\t\t\t\thealthContainer.Size = UDim2.new(1, 0, 0.2, 0)\n\t\t\t\thealthContainer.Visible = true\n\t\t\t\thealthContainer.ZIndex = 11\n\t\t\t\thealthContainer.Parent = icon.instances.iconButton\n\n\t\t\t\tlocal corner = Instance.new(\"UICorner\")\n\t\t\t\tcorner.CornerRadius = UDim.new(1, 0)\n\t\t\t\tcorner.Parent = healthContainer\n\n\t\t\t\tlocal healthFrame = healthContainer:Clone()\n\t\t\t\thealthFrame.Name = \"HealthFrame\"\n\t\t\t\thealthFrame.BackgroundColor3 = Color3.fromRGB(167, 167, 167)\n\t\t\t\thealthFrame.BorderSizePixel = 0\n\t\t\t\thealthFrame.AnchorPoint = Vector2.new(0.5, 0.5)\n\t\t\t\thealthFrame.Position = UDim2.new(0.5, 0, 0.5, 0)\n\t\t\t\thealthFrame.Size = UDim2.new(1, -2, 1, -2)\n\t\t\t\thealthFrame.Visible = true\n\t\t\t\thealthFrame.ZIndex = 12\n\t\t\t\thealthFrame.Parent = healthContainer\n\n\t\t\t\tlocal healthBar = healthFrame:Clone()\n\t\t\t\thealthBar.Name = \"HealthBar\"\n\t\t\t\thealthBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\n\t\t\t\thealthBar.BorderSizePixel = 0\n\t\t\t\thealthBar.AnchorPoint = Vector2.new(0, 0.5)\n\t\t\t\thealthBar.Position = UDim2.new(0, 0, 0.5, 0)\n\t\t\t\thealthBar.Size = UDim2.new(0.5, 0, 1, 0)\n\t\t\t\thealthBar.Visible = true\n\t\t\t\thealthBar.ZIndex = 13\n\t\t\t\thealthBar.Parent = healthFrame\n\n\t\t\t\tlocal START_HEALTHBAR_COLOR = Color3.fromRGB(27, 252, 107)\n\t\t\t\tlocal MID_HEALTHBAR_COLOR = Color3.fromRGB(250, 235, 0)\n\t\t\t\tlocal END_HEALTHBAR_COLOR = Color3.fromRGB(255, 28, 0)\n\n\t\t\t\tlocal function powColor3(color, pow)\n\t\t\t\t\treturn Color3.new(\n\t\t\t\t\t\tmath.pow(color.R, pow),\n\t\t\t\t\t\tmath.pow(color.G, pow),\n\t\t\t\t\t\tmath.pow(color.B, pow)\n\t\t\t\t\t)\n\t\t\t\tend\n\n\t\t\t\tlocal function lerpColor(colorA, colorB, frac, gamma)\n\t\t\t\t\tgamma = gamma or 2.0\n\t\t\t\t\tlocal CA = powColor3(colorA, gamma)\n\t\t\t\t\tlocal CB = powColor3(colorB, gamma)\n\t\t\t\t\treturn powColor3(CA:Lerp(CB, frac), 1/gamma)\n\t\t\t\tend\n\n\t\t\t\tlocal firstTimeEnabling = true\n\t\t\t\tlocal function listenToHealth(character)\n\t\t\t\t\tif not character then\n\t\t\t\t\t\treturn\n\t\t\t\t\tend\n\t\t\t\t\tlocal humanoid = character:WaitForChild(\"Humanoid\", 10)\n\t\t\t\t\tif not humanoid then\n\t\t\t\t\t\treturn\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal function updateHealthBar()\n\t\t\t\t\t\tlocal realHealthbarEnabled = starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Health)\n\t\t\t\t\t\tlocal healthInterval = humanoid.Health / humanoid.MaxHealth\n\t\t\t\t\t\tif healthInterval == 1 or IconController.healthbarDisabled or (firstTimeEnabling and realHealthbarEnabled == false) then\n\t\t\t\t\t\t\tif icon.enabled then\n\t\t\t\t\t\t\t\ticon:setEnabled(false)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\telseif healthInterval < 1 then\n\t\t\t\t\t\t\tif not icon.enabled then\n\t\t\t\t\t\t\t\ticon:setEnabled(true)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tfirstTimeEnabling = false\n\t\t\t\t\t\t\tif realHealthbarEnabled then\n\t\t\t\t\t\t\t\tstarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\tlocal startInterval = 0.9\n\t\t\t\t\t\tlocal endInterval = 0.1\n\t\t\t\t\t\tlocal m = 1/(startInterval - endInterval)\n\t\t\t\t\t\tlocal c = -m*endInterval\n\t\t\t\t\t\tlocal colorIntervalAbsolute = (m*healthInterval) + c\n\t\t\t\t\t\tlocal colorInterval = (colorIntervalAbsolute > 1 and 1) or (colorIntervalAbsolute < 0 and 0) or colorIntervalAbsolute\n\t\t\t\t\t\tlocal firstColor = (healthInterval > 0.5 and START_HEALTHBAR_COLOR) or MID_HEALTHBAR_COLOR\n\t\t\t\t\t\tlocal lastColor = (healthInterval > 0.5 and MID_HEALTHBAR_COLOR) or END_HEALTHBAR_COLOR\n\t\t\t\t\t\tlocal doubleSubtractor = (1-colorInterval)*2\n\t\t\t\t\t\tlocal modifiedColorInterval = (healthInterval > 0.5 and (1-doubleSubtractor)) or (2-doubleSubtractor)\n\t\t\t\t\t\tlocal newHealthFillColor = lerpColor(lastColor, firstColor, modifiedColorInterval)\n\t\t\t\t\t\tlocal newHealthFillSize = UDim2.new(healthInterval, 0, 1, 0)\n\t\t\t\t\t\thealthBar.BackgroundColor3 = newHealthFillColor\n\t\t\t\t\t\thealthBar.Size = newHealthFillSize\n\t\t\t\t\tend\n\n\t\t\t\t\thumanoid.HealthChanged:Connect(updateHealthBar)\n\t\t\t\t\tIconController.healthbarDisabledSignal:Connect(updateHealthBar)\n\t\t\t\t\tupdateHealthBar()\n\t\t\t\tend\n\t\t\t\tlocalPlayer.CharacterAdded:Connect(function(character)\n\t\t\t\t\tlistenToHealth(character)\n\t\t\t\tend)\n\t\t\t\ttask.spawn(listenToHealth, localPlayer.Character)\n\t\t\tend)\n\tend)\nend\n\n\n\n-- BEHAVIOUR\n--Controller support\ncoroutine.wrap(function()\n\t\n\t-- Create PC 'Enter Controller Mode' Icon\n\trunService.Heartbeat:Wait() -- This is required to prevent an infinite recursion\n\tlocal Icon = require(script.Parent)\n\tlocal controllerOptionIcon = Icon.new()\n\t\t:setProperty(\"internalIcon\", true)\n\t\t:setName(\"_TopbarControllerOption\")\n\t\t:setOrder(100)\n\t\t:setImage(\"rbxassetid://5278150942\")\n\t\t:setRight()\n\t\t:setEnabled(false)\n\t\t:setTip(\"Controller mode\")\n\t\t:setProperty(\"deselectWhenOtherIconSelected\", false)\n\n\t-- This decides what controller widgets and displays to show based upon their connected inputs\n\t-- For example, if on PC with a controller, give the player the option to enable controller mode with a toggle\n\t-- While if using a console (no mouse, but controller) then bypass the toggle and automatically enable controller mode\n\tlocal function determineDisplay()\n\t\tlocal mouseEnabled = userInputService.MouseEnabled\n\t\tlocal controllerEnabled = userInputService.GamepadEnabled\n\t\tlocal iconIsSelected = controllerOptionIcon.isSelected\n\t\tif mouseEnabled and controllerEnabled then\n\t\t\t-- Show icon\n\t\t\tcontrollerOptionIcon:setEnabled(true)\n\t\telseif mouseEnabled and not controllerEnabled then\n\t\t\t-- Hide icon, disableControllerMode\n\t\t\tcontrollerOptionIcon:setEnabled(false)\n\t\t\tIconController._enableControllerMode(false)\n\t\t\tcontrollerOptionIcon:deselect()\n\t\telseif not mouseEnabled and controllerEnabled then\n\t\t\t-- Hide icon, _enableControllerMode\n\t\t\tcontrollerOptionIcon:setEnabled(false)\n\t\t\tIconController._enableControllerMode(true)\n\t\tend\n\tend\n\tuserInputService:GetPropertyChangedSignal(\"MouseEnabled\"):Connect(determineDisplay)\n\tuserInputService.GamepadConnected:Connect(determineDisplay)\n\tuserInputService.GamepadDisconnected:Connect(determineDisplay)\n\tdetermineDisplay()\n\n\t-- Enable/Disable Controller Mode when icon clicked\n\tlocal function iconClicked()\n\t\tlocal isSelected = controllerOptionIcon.isSelected\n\t\tlocal iconTip = (isSelected and \"Normal mode\") or \"Controller mode\"\n\t\tcontrollerOptionIcon:setTip(iconTip)\n\t\tIconController._enableControllerMode(isSelected)\n\tend\n\tcontrollerOptionIcon.selected:Connect(iconClicked)\n\tcontrollerOptionIcon.deselected:Connect(iconClicked)\n\n\t-- Hide/show topbar when indicator action selected in controller mode\n\tuserInputService.InputBegan:Connect(function(input,gpe)\n\t\tif not IconController.controllerModeEnabled then return end\n\t\tif input.KeyCode == Enum.KeyCode.DPadDown then\n\t\t\tif not guiService.SelectedObject and checkTopbarEnabledAccountingForMimic() then\n\t\t\t\tIconController.setTopbarEnabled(true,false)\n\t\t\tend\n\t\telseif input.KeyCode == Enum.KeyCode.ButtonB then\n\t\t\tIconController._previousSelectedObject = guiService.SelectedObject\n\t\t\tIconController._setControllerSelectedObject(nil)\n\t\t\tIconController.setTopbarEnabled(false,false)\n\t\tend\n\t\tinput:Destroy()\n\tend)\n\n\t-- Setup overflow icons\n\tfor alignment, detail in pairs(alignmentDetails) do\n\t\tif alignment ~= \"mid\" then\n\t\t\tlocal overflowName = \"_overflowIcon-\"..alignment\n\t\t\tlocal overflowIcon = Icon.new()\n\t\t\t\t:setProperty(\"internalIcon\", true)\n\t\t\t\t:setImage(6069276526)\n\t\t\t\t:setName(overflowName)\n\t\t\t\t:setEnabled(false)\n\t\t\tdetail.overflowIcon = overflowIcon\n\t\t\toverflowIcon.accountForWhenDisabled = true\n\t\t\tif alignment == \"left\" then\n\t\t\t\toverflowIcon:setOrder(math.huge)\n\t\t\t\toverflowIcon:setLeft()\n\t\t\t\toverflowIcon:set(\"dropdownAlignment\", \"right\")\n\t\t\telseif alignment == \"right\" then\n\t\t\t\toverflowIcon:setOrder(-math.huge)\n\t\t\t\toverflowIcon:setRight()\n\t\t\t\toverflowIcon:set(\"dropdownAlignment\", \"left\")\n\t\t\tend\n\t\t\toverflowIcon.lockedSettings = {\n\t\t\t\t[\"iconImage\"] = true,\n\t\t\t\t[\"order\"] = true,\n\t\t\t\t[\"alignment\"] = true,\n\t\t\t}\n\t\tend\n\tend\n\n\t-- This checks if voice chat is enabled\n\tlocal success, enabled = pcall(function() return voiceChatService:IsVoiceEnabledForUserIdAsync(localPlayer.UserId) end)\n\tif success and enabled then\n\t\tisVoiceChatEnabled = true\n\t\tIconController.updateTopbar()\n\tend\n\n\t-- Credit\n\tif not isStudio then\n\t\tlocal ownerId = game.CreatorId\n\t\tlocal groupService = game:GetService(\"GroupService\")\n\t\tif game.CreatorType == Enum.CreatorType.Group then\n\t\t\tlocal success, ownerInfo = pcall(function() return groupService:GetGroupInfoAsync(game.CreatorId).Owner end)\n\t\t\tif success then\n\t\t\t\townerId = ownerInfo.Id\n\t\t\tend\n\t\tend\n\t\tlocal version = require(script.Parent.VERSION)\n\t\tif localPlayer.UserId ~= ownerId then\n\t\t\tlocal marketplaceService = game:GetService(\"MarketplaceService\")\n\t\t\tlocal success, placeInfo = pcall(function() return marketplaceService:GetProductInfo(game.PlaceId) end)\n\t\t\tif success and placeInfo then\n\t\t\t\tlocal gameName = placeInfo.Name\n\t\t\t\tprint((\"\\n\\n\\n\u{26bd} %s uses TopbarPlus %s\\n\u{1f34d} TopbarPlus was developed by ForeverHD and the Nanoblox Team\\n\u{1f680} You can learn more and take a free copy by searching for 'TopbarPlus' on the DevForum\\n\\n\"):format(gameName, version))\n\t\t\tend\n\t\tend\n\tend\n\nend)()\n\n-- Mimic the enabling of the topbar when StarterGui:SetCore(\"TopbarEnabled\", state) is called\ncoroutine.wrap(function()\n\tlocal chatScript = players.LocalPlayer.PlayerScripts:WaitForChild(\"ChatScript\", 4) or game:GetService(\"Chat\"):WaitForChild(\"ChatScript\", 4)\n\tif not chatScript then return end\n\tlocal chatMain = chatScript:FindFirstChild(\"ChatMain\")\n\tif not chatMain then return end\n\tlocal ChatMain = require(chatMain)\n\tChatMain.CoreGuiEnabled:connect(function()\n\t\tlocal topbarEnabled = checkTopbarEnabled()\n\t\tif topbarEnabled == IconController.previousTopbarEnabled then\n\t\t\tIconController.updateTopbar()\n\t\t\treturn \"SetCoreGuiEnabled was called instead of SetCore\"\n\t\tend\n\t\tif IconController.mimicCoreGui then\n\t\t\tIconController.previousTopbarEnabled = topbarEnabled\n\t\t\tif IconController.controllerModeEnabled then\n\t\t\t\tIconController.setTopbarEnabled(false,false)\n\t\t\telse\n\t\t\t\tIconController.setTopbarEnabled(topbarEnabled,false)\n\t\t\tend\n\t\tend\n\t\tIconController.updateTopbar()\n\tend)\n\tlocal makeVisible = checkTopbarEnabled()\n\tif not makeVisible and not IconController.mimicCoreGui then\n\t\tmakeVisible = true\n\tend\n\tIconController.setTopbarEnabled(makeVisible, false)\nend)()\n\n-- Mimic roblox menu when opened and closed\nguiService.MenuClosed:Connect(function()\n\tmenuOpen = false\n\tif not IconController.controllerModeEnabled then\n\t\tIconController.setTopbarEnabled(IconController.topbarEnabled,false)\n\tend\nend)\nguiService.MenuOpened:Connect(function()\n\tmenuOpen = true\n\tIconController.setTopbarEnabled(false,false)\nend)\n\nbindCamera()\n\n\nreturn IconController"
IconController.Parent = Icon

Icon.Parent = game:GetService("ReplicatedStorage")
return Icon
